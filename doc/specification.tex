\documentclass[dvipsnames]{article}

\usepackage{fontspec}
\usepackage{polyglossia}
% \usepackage{bbding}
% \usepackage{csquotes}
% \usepackage{endnotes}
\usepackage{hyperref}
\usepackage{dingbat}
\usepackage{tabularx}
% \usepackage{ltablex}
\usepackage{stmaryrd}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{tikz}
\usepackage{caption}
\usepackage{siunitx}
\usepackage{mathtools}
\usepackage{adjustbox}
\usepackage{fancybox}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{colonequals}
\usepackage{xspace}
% \usepackage{amssymb}
% \usepackage{amsmath}
\usepackage{wasysym}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{minted}
\usepackage{enumitem}

\newcommand*\circled[1]{
  \tikz[baseline=(char.base)]{
    \node[shape=circle,draw,inner sep=0.5pt] (char) {#1};}}

\newcommand{\ie}{i.e.\@\xspace}
\newcommand{\eg}{e.g.\@\xspace}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{decorations.pathreplacing}
\setlength{\arraycolsep}{0.078cm}
\setlength{\parskip}{0.2cm}

% For nested parentheses
% \delimitershortfall=0pt


\definecolor{light-gray}{gray}{0.9} 
\setminted{
  framesep=2mm,
  baselinestretch=1.1,
  bgcolor=light-gray,
  breaklines,
  fontsize=\footnotesize,
  linenos
}


% English language
% \setdefaultlanguage{french}
% \MakeOuterQuote{"}
% \renewcommand{\theendnote}{\Roman{endnote}}
\hypersetup{
  colorlinks = true,
  linkcolor = blue
}
% \renewcommand*{\enoteheading}{}


% Remove the table of contents header.
\makeatletter
\renewcommand\tableofcontents{%
  \setlength{\parskip}{0cm}
  \@starttoc{toc}%
  \setlength{\parskip}{0.2cm}
}
\makeatother

\newcommand{\ab}{{Atelier~B}}
\newcommand{\br}{\texttt{b2rust}}
\newcommand{\tx}{\texttt{tinyxml2}}

% Used for regular expressions.
\makeatletter
\def\+{\@postfix+}
\def\*{\@postfix*}
\def\?{\@postfix?}
\def\@postfix#1{{#1}\@ifnextchar){}{\;}}
% \newcommand{\deriv}[3][]{% \deriv[<order>]{<func>}{<var>}
% \ensuremath{\frac{\partial^{#1} {#2}}{\partial {#3}^{#1}}}}
\setlength{\fboxsep}{1pt}
\setlength{\shadowsize}{0.8pt}

\noexpandarg\exploregroups      % Mandatory for such usage of \StrSubstitute!

\newcommand{\CR}{\raisebox{2pt}{\carriagereturn}}
\newcommand{\rtext}[1]{
  \raisebox{-2pt}{\shadowbox{\texttt{\StrSubstitute{#1}{ }{\textvisiblespace}}}}
}
\newcommand{\gram}[1]{%
  \StrSubstitute{#1}{'}{\textsubscript{\texttt{b2r}}}[\corr]
  \underline{\textsf{%
      \hypersetup{linkcolor=MidnightBlue}%
      \hyperlink{g#1}{\corr}%
    }}}
\newcommand{\gramN}[1]{%
  \StrSubstitute{#1}{'}{\textsubscript{\texttt{b2r}}}[\corr]
  \underline{\textsf{%
      \color{Gray}\corr%
    }}}
\newcommand{\gramdef}[1]{\hypertarget{g#1}{\gram{#1}}}
% \newcommand{\rs}{\rightarrow}
% \newcommand{\nrs}{\twoheadrightarrow}
\newcommand{\comp}[2]{
  \begin{adjustbox}{center}
    \begin{minipage}{0.5\textwidth}
      #1
    \end{minipage}
    \hspace{0.7cm}
    \begin{minipage}{0.5\textwidth}
      #2
    \end{minipage}
  \end{adjustbox}
}

\DeclareMathOperator{\set}{\qset}
\DeclareMathOperator{\tuple}{\qlist}

% st: struct type.
\newcommand{\st}[1]{%
  \StrSubstitute{#1}{\_}{ToHaveWorkingLinksThisTextShouldNotBeReplicatedByAccidentEiD5MaaK}[\link]
  \underline{\textsf{%
      \hypersetup{linkcolor=ForestGreen}%
      \hyperlink{st\link}{#1}%
    }}}
% Blind struct type.
\newcommand{\bst}[1]{\underline{\textsf{#1}}}

% std: struct type def.
\newcommand{\std}[2]{
  \StrSubstitute{#1}{\_}{ToHaveWorkingLinksThisTextShouldNotBeReplicatedByAccidentEiD5MaaK}[\link]
  \begin{adjustbox}{center}
    \(
      \hypertarget{st\link}{
        \st{#1} = #2
      }
    \)
  \end{adjustbox}
}


% structure
\newcommand{\Struct}[1]{
  \left[
    \begin{array}{ll}
      #1
    \end{array}
  \right]
}
\newcommand{\OStruct}[1]{
  \left\downarrow
    \begin{array}{ll}
      #1
    \end{array}
  \right\downarrow
}


% structure set
\newcommand{\StructS}[1]{
  \left\llbracket
    \begin{array}{ll}
      #1
    \end{array}
  \right\rrbracket
}
\newcommand{\OStructS}[1]{
  \left\Downarrow
        \begin{array}{ll}
          #1
          \end{array}
  \right\Downarrow
}

% Restriction to unordered structure
\newcommand{\rus}[1]{#1\rangle}

\newcommand{\tos}{\mathcal{S}_\rightarrow}

% fot is field of type.
\newcommand{\fot}[2]{\textsf{#1} &\colon #2}
\newcommand{\fotm}[2]{#1 &\colon #2}

% field definition
\newcommand{\fdef}[2]{\textsf{#1} &:\in #2}
\newcommand{\fdefm}[2]{#1 &:\in #2}

% Implicit field definition
\newcommand{\imfdef}[1]{\multicolumn{2}{l}{#1}}

% Types
\DeclareMathOperator{\str}{\mathbb{S}}
\DeclareMathOperator{\tint}{\mathbb{Z}}
\DeclareMathOperator{\bool}{\mathbb{B}}
\DeclareMathOperator{\tnat}{\mathbb{N}}
\newcommand{\nxt}{\rightarrow}
\newcommand{\nl}{\downarrow}

\newcommand{\toelement}[1]{\lVert #1 \rVert}

\newcommand{\ulobj}[1]{\ovalbox{\textsf{#1}}}

\def
\ec{{%
    \setbox0\hbox{!}%
    \rlap{\hbox to \wd0{\hss,\hss}}\box0
    \ 
}}


\DeclareMathOperator{\qset}{set_{q}}
\DeclareMathOperator{\dset}{set_{d}}
\DeclareMathOperator{\qlist}{list_{q}}
\DeclareMathOperator{\dlist}{list_{d}}



\newcommand{\omap}[2]{\mathrm{map_{o}}\!\left[#1\right] #2}
\newcommand{\umap}[2]{\mathrm{map_{u}}\!\left[#1\right] #2}

\newcommand{\sref}[1]{.\textsf{#1}}
\newcommand{\srefq}[1]{#1\cdot}


% Function definition.
\newcommand{\fun}[2]{
  \begin{adjustbox}{center}
    \(
    #1 \colon \left\{
      \begin{array}{ccl}
        #2
      \end{array}
      \right.
    \)
  \end{adjustbox}
}

\begin{document}

\thispagestyle{empty}
\null

\vfill

\begin{center}
  \Huge {\br} specification
  \vspace{2cm}

  \LARGE A C++ B-to-Rust converter \\

  \vspace{1cm}
  \large Elouan Fabre, Paris. \\

  \smallskip
  \today.
  \vspace{1cm}
\end{center}

\vfill

\newpage

\section{Preamble}

\subsection{Abstract}

{\br} is written in C++ and converts a B~program into a Rust~library (a set of Rust code files) which can be compiled without errors (but not necessarily without warnings). The functions it defines can be used in a separate Rust project.
% Doesn’t work anymore.
% or, if the \texttt{--check-only} option, might tells you if it can.
Its calling syntax (section~\ref{calling}) is the following:

\noindent
\texttt{b2rust module -I directory} \\
% \indent\texttt{[--check-only]}
\indent\texttt{[-O output\_directory]}

If an \texttt{output\_directory} is not provided, the Rust~library will be generated in the current directory.

Input requirements (section~\ref{calling}):
\begin{itemize}
\item \texttt{module} is the base module or entry module: the module which recursively imports every module and which is not imported by any module.
\item \texttt{directory} must be accessible and contain the base module (so, the files \texttt{directory/module.bxml} and \texttt{directory/module\_i.bxml} must exist and be readable) as well as any imported component (which have to be implemented). All these files have to be BXML~1.0 compliant files.
\item  {\br} needs to have write access to \texttt{output\_directory}. It should not already contain files whose name are under the shape \texttt{i.rs}, where \texttt{i} is the name of a module in \texttt{directory}.
\end{itemize}

If these requirements are not respected, an unknown behaviour could happen.

If the B module associated with the \texttt{module.bxml} and \texttt{module\_i.bxml} as well as recursively imported modules codes match some specifications (section~\ref{subset}), {\br} shall generate a Rust library (a code file for each module whose name is the name of the module) which matches the specification of the B entry module. To put in a nutshell, {\br} translates variables, constants, assignments, \texttt{if}/\texttt{then}/\texttt{else}, asserts, local variables definitions, operation definition with any number of input or output parameters, imports, operation calls, some expressions using tabulars, integers, booleans, basic maths.

The library can be compiled with the command \texttt{rustc --crate-type=lib a.rs} (if \texttt{a.rs} is the generated file). The library can then be used in a Rust project (with a \texttt{main}), using the compilation option \texttt{--extern out=libout.rlib} (section~\ref{usage}).

Run \texttt{cmake . \&\& make} if you want to compile, \texttt{ctest .} if you want to run the tests (section~\ref{testing}).

% No more
% In all cases, {\br} does a checking of your implementation file which shall prevent the conversion from happening if the associated B~program doesn't match the grammar.


\subsection{About this document}

% TODO: verify spelling.
This document introduces a B-to-Rust converter written by Elouan Fabre in CLEARSY in 2022 and 2023. It should be the entry point for anyone who:
\begin{itemize}
\item Just wants to compile {\br} and run the test bench;
\item Seeks to use {\br} on a B0 project written by {\ab}, given its BXML associated files;
\item Wants to understand the functionalities of {\br} or its conversion scheme;
\item Wants to improve {\br}.
\end{itemize}

Every remark you have can be sent by mail to the following address: \href{mailto:elouan.fabre@clearsy.com}{\texttt{elouan.fabre@clearsy.com}} at least until June 27\textsuperscript{th}, 2023. After this date, you should send a mail to CLEARSY. Anyway, I am, until this same date, open to pull requests correcting this document (especially concerning the spelling or the grammar corrections).




\subsection{Table of contents}

\tableofcontents


\section{Introduction}

The \textit{B~method} is a good way to write formally verified programs when dealing with highly sensitive field of activity like nuclear activities or railway. It consist in writing a program specification using the B~language, and then progressively refining it to a program written in a Turing-complete subset of the B language\footnote{With some exceptions; it is the case here with {\br} which can translate a "non-Turing B instruction" (in B terminology, a B substitution which is not a B instruction) which is the \gram{Substitution\_devient\_elt\_de'} substitution.}, for example, B0. A B0 program is quite close to a program written in a high-level language like Python or BASIC and is fairly algorithmic. However, unlike most programming languages, B0 has no default dedicated compiler to machine code. It can seem disconcerting because formally verified machine code is, undoubtedly, the final goal of formal methods. Some still exist, like B32, which compiles the B0 code to MIPS assembly. However, due to safety concerns, it is much preferable to write several converters to different programming languages and then compare their results on a same B0 program.

These last years, the Rust language has gained some attractiveness in the field of the safety. Rust has some nice features to provide an error-free program, for example by preventing the definition of references to freed objects. Some good converters exist like ComenC for the C language, but there were, until today, no converters for the Rust language.
% TODO: more examples?
This is the reason why CLEARSY has suggested the creation of a B-to-Rust converter.

However, {\br} won't recognize exactly B0 which is an arbitrary subset of the B~language; but, as B0 quite stands as a reference in the B~environment, it shall be referenced a lot through this document.


Depending on the goal of the reader, a section or another can raise your interest. You may find below the different sections of this document, their purpose and their reference:
\begin{itemize}
\item How to compile and test {\br} (section~\ref{SectionSetup});
\item How to use {\br} (section~\ref{SectionUsage});
\item Which types of B0 components does {\br} correctly parse and translate (section~\ref{subset});
\item What is the translation specifications of {\br} (section~\ref{TranslationScheme});
\item How does {\br} work (section~\ref{SectionInnerWorkings});
\item What are the development conventions of the development of {\br} (section~\ref{SectionCoding}).
\end{itemize}


\section{Setup}
\label{SectionSetup}


\subsection{Compilation of {\br}}

The compilation needs CMake, Make, and a C++ compiler. Manage to have them installed on your computer. {\br} needs {\tx}, a library used to read the BXML file (which is a specific XML file), and already used in {\ab}. If you want to compile {\br}, you need to have the headers and the dynamic libraries of {\tx} installed. On Void Linux, this is done with the following command:

\begin{minted}{text}
# xbps-install tinyxml2-devel tinyxml2
\end{minted}


% If you just want to run {\br} on another machine, you just need the dynamic library:

% \begin{minted}{text}
%   # xbps-install tinyxml2
% \end{minted}

Now, get the {\br} source code and navigate to the file. On at least all UNIX platforms, you probably just need the following commands:
\begin{minted}{text}
$ cmake .
$ make .
\end{minted}


\subsection{Generate the documentation}

For now, the documentation only consists of the document you are reading ({\br} specification), which is written with Lua\LaTeX, successor of \LaTeX. The PDF file is in the \texttt{doc} folder (it’s \texttt{specification.pdf}), however, if you update the source file \texttt{specification.tex} which you can find in the same directory, or if you just want a document freshly compiled, you can just navigate to the directory and compile the document. To do this, you need a {\TeX} distribution which provides {Lua\LaTeX} and the packages used in the \texttt{.tex} document. On Void Linux, you can achieve this with the following command:

\begin{minted}{text}
# xbps-install texlive-full
\end{minted}

However, this is a little "overkill" and you probably can install a bit less than all the {\LaTeX} packages, thus ending up with an installation of less than several gibibytes. Anyhow, you can generate the PDF by navigating to the \texttt{doc} folder and using the command:

\begin{minted}{text}
$ lualatex --shell-escape specification.tex
\end{minted}
% $

(The \texttt{--shell-escape} flag is needed by the \texttt{minted} package which allows to print code.)



\subsection{Testing}
\label{testing}

% TODO: replace \texttt with something prettier (and more distinct).

{\br} comes with an adaptative test bench. It is configured with CMake, but before executing \texttt{ctest .} to run all the tests, you need to run \texttt{cmake .} first, for a reason explained \hyperlink{adaptative}{later}. A test consists of a directory of a certain name. There are four different types of tests: \textit{call\_error} tests, \textit{comparison} tests, \textit{error} tests and \textit{main} tests. A test of name $n$ is the directory \texttt{tests/$c$/$n$}, where $c$ is the name of its category. For any category $c$, a \texttt{tests/$c$/test.sh} file exists; its role is to proceed with a certain test of the $c$ category. If the test requires BXML files, {\br} takes as input the directory \texttt{tests/$c$/$n$} and \texttt{$n$} as name of the module to use as entry point.

\begin{enumerate}
\item A \textit{call\_error} calls {\br} with calling options which should fail. It is used to test the parameters parsing. If the test name is $n$, the file \texttt{tests/$c$/$n$/command} contains the parameters to append to the call of {\br} and \texttt{tests/$c$/$n$/error} contains the error code we should get. If the programs fails with a bad error code, the test fails. Otherwise, it succeeds.
\item A \textit{comparison} test compares the output file {\br} generates for the entry module with a \texttt{.rs} file.
% TODO_12 Speak about rustfmt
  If these two files are \SI{100}{\percent} identical, the test succeeds. Otherwise, it fails.
  \begin{figure}
\begin{verbatim}
[do_test.sh] Proceeding test `skip_operation`... Info: you can run yourself the
code generation part of the test with the command /home/efabre/Documents/b2rust/bin/b2rust
-a /home/efabre/Documents/b2rust/tests/bxml//skip_operation/skip_operation.bxml
-i /home/efabre/Documents/b2rust/tests/bxml//skip_operation/skip_operation_i.bxml.
✖ Test failed.
The reference file is
┌─────────────────────────────────────────────────────────────────────┐
│fn main() {                                                          │
│}                                                                    │
│fn skip_m() {                                                        │
│}                                                                    │
└─────────────────────────────────────────────────────────────────────┘
but the file generated by b2rust is:
┌─────────────────────────────────────────────────────────────────────┐
│fn main() {                                                          │
│}                                                                    │
│fn skip_me() {                                                       │
│}                                                                    │
└─────────────────────────────────────────────────────────────────────┘
If you don’t see the difference, here’s a `diff` output:
┌─────────────────────────────────────────────────────────────────────┐
│3c3                                                                  │
│< fn skip_me() {                                                     │
│---                                                                  │
│> fn skip_m() {                                                      │
└─────────────────────────────────────────────────────────────────────┘
\end{verbatim}
  \caption{\label{failedtest}Example of output of \texttt{do\_test.sh} in case of failed test. This output is the one of an old version of {\br}, so, don’t be surprised by this output.}
\end{figure}
  If a test fails, a \texttt{diff} output is printed. It can be quite useful (figure~\ref{failedtest}). In any case, the output of {\br} is printed, as well as the executed command. If the test name ({\ie} the directory name) is $n$, the output of {\br} is compared with the \texttt{r\_$n$.rs} file.
\item A \textit{error} test is similar to a \texttt{call\_error} test, but the changing parameter is the content of the BXML~files (and not the calling parameters). It is useful because {\br} shan't output any code if the input files do not respect \hyperref[subset]{the specifications}. However, it should not throw a segmentation fault error, for example.
\item A \textit{main} test is a more interesting test. It does the following:
  \begin{enumerate}
  \item It executes {\br} with the given directory and module name;
  \item The code associated to the entry module and produced by {\br} is compiled to a library;
  \item \label{binarytest}A Rust code file provided by the user is also compiled with linking to the created library;
  \item The created binary is executed.
  \end{enumerate}
  If all these steps succeed ({\ie} with the error code 0), the test succeeds. Otherwise, it fails. If the name of the test is $n$, then, the code provided by the user needs to be \texttt{tests/main/$n$/main.rs}.
  This test is interesting because it simulate the action an end-user would do like specified in the section~\ref{usage}.
\end{enumerate}

\hypertarget{adaptative}{The test bench is \textit{adaptative}: it is generated each time you run \texttt{cmake .}.}
% TODO_12: update the diagram.
% \begin{figure}
%   \begin{adjustbox}{center}
% \begin{tikzpicture}
%   \node [draw, rounded corners] (bxml) at (0, 0) {
%     \texttt{function\_test.bxml}
%   };
%   \node [draw, rounded corners] (ibxml) at (4.5, 0) {
%     \texttt{function\_test\_i.bxml}
%   };
%   \node [] (ftbxml) at (2.25, 1.5) {
%     \texttt{function\_test/}
%   };
%   \node [] (ftrust) at (9, 1.5) {
%     \texttt{function\_test.rs}
%   };

%   \node [] (bxmldir) at (2.25, 3) {
%     \texttt{bxml/}
%   };
%   \node [] (referencedir) at (9, 3) {
%     \texttt{reference/}
%   };  

%   \node [] (testsdir) at (5.625, 4.5) {
%     \texttt{tests/}
%   };

%   \draw [->, thick] (testsdir) -- (bxmldir);
%   \draw [->, thick] (testsdir) -- (referencedir);
%   \draw [->, thick] (bxmldir) -- (ftbxml);
%   \draw [->, thick] (referencedir) -- (ftrust);
%   \draw [->, thick] (ftbxml) -- (bxml);
%   \draw [->, thick] (ftbxml) -- (ibxml);
% \end{tikzpicture}
% \end{adjustbox}
% \caption{\label{testDiagram}The test directory structure: here is a minimal working example. There’s only one test here which is \texttt{function\_test}. The node are directories, the circled nodes are files. A lot of important files have not be represented on the diagram, like the Bash scripts.}
% \end{figure}
% The \texttt{CMakeLists.txt} file is told to run the \texttt{gen\_tests.sh} which aims at searching for the pairs of files (a BXML file and a Rust file), and, for each found pair, adds a test for it.
Its inner working is not complicated; for each category $c$ of tests, it goes over each directory of \texttt{tests/$c$}, and generate a line inside the \texttt{tests\_file.cmake} file (the one CMake executes when you run \texttt{cmake .}) telling it to run the \texttt{$c$/test.sh} script with the correct arguments matching to the one we want for the found test.
Note that the generation of tests is "blind" as it doesn’t check if the tests match the specification of their category given \hyperref[testing]{above}.

Notice the script \texttt{gen\_bxml.sh} script; please do not consider it as a part of the {\br} environment, but rather as a script you might find helpful. It can help you adding your own tests from \texttt{.mch} and \texttt{.imp} files rather than from \texttt{.bxml} files. To do this, you just need to provide the Atelier~B \texttt{bbin} directory which contains its executables as well as the path to the \texttt{tests} directory and Atelier~B's ressource file. The script shall go over all the tests of every category ({\ie} all the tests) and generate every BXML file it can (it goes over all the found \texttt{.mch} and \texttt{.imp} files). It is the reason why you may found \texttt{.mch} and \texttt{.imp} files in each BXML reference folder; they are just "convenience" files which do not match any specification, but you may find them helpful. \texttt{gen\_bxml.sh} has hardcoded paths to BXML files it shouldn’t generate; it is used for \texttt{errors} tests.

You might find another script useful: \texttt{test\_command.sh} which just starts {\br} on a given test (so that you doesn’t have to type its arguments which can be long in the case of a test).

In any case, some useful information are printed during the tests, but CMake doesn’t print the output of the tests by default. If you want to print them, run \texttt{ctest . -V}. Note that \texttt{ctest . -V -R test\_3615} will print the output of \texttt{do\_test.sh} for the test \texttt{test\_3615}. 

In any case, some useful information are printed during the tests, but CMake doesn’t print the output of the tests by default. If you want to print them, run \texttt{ctest . -V}. Note that \texttt{ctest . -V -R test\_3615} will print the output of \texttt{do\_test.sh} for the test \texttt{test\_3615}. 

\section{Using {\br}}
\label{SectionUsage}

This section shall explain how one can use {\br} and the calling specification he would have to respect but without going into too much detail; in particular, it doesn’t explain the specifications the BXML files have to respect. It is the role of the section~\ref{subset} to explain the specification your files have to meet in order to have a desired output. If you respect the requirements of the section you are reading and the ones of the section~\ref{subset}, it is in the specification of {\br} that your components shall be translated into a compilable Rust program (eventually made up of several files).


\subsection{{\br} calling options}
\label{calling}

Currently, {\br} only works on B "modules". If you want to use {\br}, you should be familiar with the B environment terminology. However, to put it in a nutshell, let's precise it is made up of an abstract machine (basically, a \texttt{.mch} file) and an implementation (basically, a \texttt{.imp} file). Yet, {\br} doesn't work on them directly; it uses BXML files. A BXML file is a more convenient shape of a B~component which allows the developer not to have to parse a B~component himself. It is a specific XML file which is automatically generated by {\ab} from a B~component using the \texttt{bxml} tool.
% TODO: really?
% Keep in mind your input files have to be generated by \texttt{bxml}, in all cases.
Then, depending on its calling parameters, {\br} shall generate a Rust program (figure~\ref{b2rust}) which can be written to \texttt{stdout} or to a file.

Also, know that the B~method allows to work on several modules, as an implementation can \textit{import} a module. However, as the importation diagram cannot contain any cycle (as long as your project is "verified"), there must be an "entry point", {\ie} a module which recursively imports all the others. We refer it as the \textit{entry module}.

So, {\br} must find the abstract machine and the implementation of the entry module and all recursively imported modules (the abstract machine is necessary to get more information on some clauses or expressions). Therefore, you need to provide the name of the B~entry module and the directory we can find the files in. The syntax is the following:

\noindent
\texttt{b2rust module -I directory} \\
% \indent\texttt{[--check-only]}
\indent\texttt{[-O output\_directory]}


\begin{itemize}
\item \texttt{module}: specify the B "entry module" name.
\item \texttt{-I directory}: specify a directory where the BXML files associated to this module and whose name have to be \texttt{module.bxml} and \texttt{module\_i.bxml} can be found; this directory should also include recursively imported modules, if any;

  % However, if at least one of this requirements are not met, {\br} will refuse to work and tell you what is wrong. However, there another requirement: \texttt{directory/module.bxml} and \texttt{directory/module\_i.bxml} files must be BXML~1.0 compliant files.  If this requirement is not met, an unknown behavior shall happen (hopefully, a segmentation fault).
  
\item \texttt{-O output\_directory}: specify an output directory where {\br} shall put the generated codes. Note that the translation of a module $(\mathtt{name.bxml}, \mathtt{name\_i.bxml})$ will be a Rust code whose name will be \texttt{name.rs}. If no \texttt{output\_directory} is provided, it will be set to \texttt{.}, the current directory.

  % If one of this requirements are not met, {\br} will refuse to work and tell you the problem.
% \item \texttt{--check-only}: tell {\br} you are not interested in code generation and just want to know if the code can be correctly translated. If so, a pleasant message will be output to \texttt{stdout}, and the error code will be \hyperref[errors]{\texttt{OK}}. If not, errors will be output to \texttt{stderr}, nothing will be written to \texttt{stdout}, and the error code will be \hyperref[errors]{\texttt{ERR\_BXML\_CHECKING}}.
  % If using the \texttt{--check-only} option, this option is useless and can be discarded.
\end{itemize}

% Concerning the classic usage (no usage of \texttt{--check-only}), if
% We shall never know what I wanted to write :)

Please note that the parameters can be given to {\br} in whatever order. However, no parameter shall be given twice! So:

\noindent
\texttt{b2rust module -I mydir -O here}

\noindent
does the same thing as:

\noindent
\texttt{b2rust -I mydir -O here module}

\noindent
, but:

\noindent
\texttt{b2rust -I mydir -O here module -O there}

\noindent
or:

\noindent
\texttt{b2rust module1 module2 -I mydir -O here}

\noindent
shall throw an error.

\begin{figure}
  \begin{adjustbox}{center}
    \begin{tikzpicture}
      \node[draw, align=center] (B0) at (3, 0) {
        B component \\ \\
        \tiny
        \begin{lstlisting}[language=xml]
MACHINE
    Example
OPERATIONS
    ...
END
        \end{lstlisting}
      };
      \node[draw, align=center] (BXML) at (7.5, 0) {
        BXML-compliant file \\ \\
        \tiny
        \begin{lstlisting}[language=xml]
<Machine>
    <Initialisation>
        ...
    </Initialisation>
    <Operations>
        ...
    </Operations>
</Machine>
        \end{lstlisting}
      };
      
      \node[draw, align=center] (B02) at (3, -3) {
        B~component \\ \\
        \tiny
        \begin{lstlisting}[language=xml]
IMPLEMENTATION
    Example_i
REFINES
    Example
OPERATIONS
    ...
END
        \end{lstlisting}
      };
      \node[draw, align=center] (BXML2) at (7.5, -3) {
        BXML-compliant file \\ \\
        \tiny
        \begin{lstlisting}[language=xml]
<Machine>
    <Abstraction>Example</Abstraction>
    <Initialisation>
        ...
    </Initialisation>
    <Operations>
        ...
    </Operations>
</Machine>
        \end{lstlisting}
      };


      % \node [draw, thick] (b2rust) at (4.7, 0) {\textbf{\texttt{b2rust}}};
      \node [draw, align=center] (Rust) at (13, -1.5) {
        Rust program \\ \\
        \tiny
        \begin{lstlisting}[language=C]
struct Example {
  ...
}
...
        \end{lstlisting}
      };
      \draw [->] (B0) -- (BXML) node[midway, above] {\texttt{bxml}};
      \draw [->] (B02) -- (BXML2) node[midway, above] {\texttt{bxml}};
      \draw [decorate, decoration={brace, amplitude=10pt}] (10, 2) -- (10, -5) node [black, midway, xshift=9pt] (brace) {};
      \draw [-{To[length=1.5mm, width=3mm]}, thick] (brace) -- (Rust) node[midway, above] {\large\texttt{b2rust}};;
    \end{tikzpicture}
  \end{adjustbox}
  \caption{\label{b2rust}\texttt{bxml} generates a BXML file from a B~component. {\br} generates a Rust code from two BXML files, which are searched in a given directory.}
\end{figure}


\subsection{Errors}

These two propositions are strictly equivalent:
\begin{enumerate}
\item The return code of the execution of {\br} is 0.
\item Rust code was generated by {\br}. The entry module code translation is compilable by \texttt{rustc} according the specification detailed in the section~\ref{usage} and match the B~specification of your components.
\end{enumerate}

If an error occurs, a message will be printed on the \texttt{stderr} stream and, hopefully, will give you some precious information. However, it is not because a code was created that it is correct!
% TODO_13 update
% If you are using {\br} in a project, know that an integer is returned by {\br} and describes the error. The file \texttt{src/error\_codes.h} uses macros to define the different error integers, and they are specified \hyperref[errors]{in the appendix}.


\subsection{Usage of generated files}
\label{usage}

\subsection{Specification of usage of the generated file}
\label{usage}


\subsubsection{Context}

The code {\br} generates is a library code; it doesn’t contain any \texttt{main} function. This allows the user to write his own \texttt{main}, which can be useful to specify the entry point of the program or to test the library on his own. A file containing only a \texttt{main} may then be compiled as long as the generated library path is specified.

So, {\br} doesn’t compile the file itself and, if its output is stored in a \texttt{a.rs} file, you can compile it with the following command:

\begin{verbatim}
$ rustc --crate-type=lib a.rs
\end{verbatim}

This will generate a \texttt{liba.rlib} file which can be included in other projects. The \texttt{rustc} command calls the Rust compiler; it can probably be installed separately, or from \texttt{rustup}, the official Rust toolchain installer. Anyway, this subject is outside the scope of this document.

The user may then want to write his own \texttt{main} function (so, in Rust), and bind it to the compiled library. If his file is \texttt{main.rs}, then, the command
\begin{verbatim}
$ rustc --extern a=liba.rlib main.rs
\end{verbatim}
will do the trick. Note, however, that a struct \texttt{struct} defined in the library needs to be referenced by the syntax \texttt{a::struct}.


\subsubsection{Specification}

All the following specifications must be respected. If they seem difficult to understand, and example is given in the section~\ref{specExample}.

\begin{enumerate}
\item Every call to a library's function \textit{must} follow the preconditions of the associated operation you may find in the abstract machine. No test is done automatically.
\item The only interface of the library you may use is the call to the functions. (Anyway, the Rust compiler should prevent any other access. Only the structure and its functions use the \texttt{pub} keyword.)
\item A call to any struct instance's function needs to be precedated by a call to the \texttt{initialisation} procedure.
\item A B operation called $f$ with the signature: $o_1, \cdots, o_n \leftarrow f(i_1, \cdots, i_m)$ is called with the syntax $f(i_1, \cdots, i_m, o_1, \cdots, o_n)$ (mind the order); however, input parameters need to be call by immutable reference to the associated Rust type and output parameters by mutable reference to the associated Rust type.
\end{enumerate}


\subsubsection{Recommandations}
\label{specExample}

Before using an operation of the component, instanciate the component (which is translated by a \texttt{struct} in Rust):

\begin{verbatim}
let mut s: component::component = Default::default();
\end{verbatim}

Note that:
\begin{enumerate}
\item The object has to be mutable (because the operation may modify the field of the struct);
\item \texttt{component} has to be replaced by the library’s name (the name of the compiled crate); hint: if the library is \texttt{libfoo.rlib}, it should be \texttt{foo};
\item The Rust struct (which matches a component) implements the \texttt{Default} trait, so, you may use the useful \texttt{default} function. As Rust refuses to call the \texttt{initialisation} if the object is not instaciated, it is even compulsory.
\end{enumerate}

Then, before doing anything, you \textit{must} run the initialisation:
\begin{verbatim}
s.initialisation();
\end{verbatim}

Now, if we want to call an operation with this signature:
\begin{verbatim}
o1, o2, o3 <-- op(i1, i2, i3) = PRE
    o1 : rust_i32 &
    o2 : rust_i8 &
    o3 : rust_i16 &
    i1 : rust_bool &
    i2 : rust_i8 &
    i3 : rust_i16
THEN
\end{verbatim}

The associated function \texttt{s.op} has six parameters matching the types specified in the specification; as the variable need to be instanciated first, your program might look like this:
\begin{verbatim}
let mut o1: i32 = 1234;
let mut o2: i8 = -67;
let mut o3: i16 = 0;
let i1: bool = false;
let i2: i8 = 12;
let i3: i16 = 0;
s.op(&i1, &i2, &i3, &mut o1, &mut o2, &mut o3);
\end{verbatim}

As Rust surprisingly accepts references to litterals, the latter code could also be written:

\begin{verbatim}
let mut o1: i32 = 1234;
let mut o2: i8 = -67;
let mut o3: i16 = 0;
s.op(&false, &12, &0, &mut o1, &mut o2, &mut o3);
\end{verbatim}


\subsection{Specification of usage of the generated file}
\label{usage}


\subsubsection{Context}

The code {\br} generates is a library code; it doesn’t contain any \texttt{main} function. This allows the user to write his own \texttt{main}, which can be useful to specify the entry point of the program or to test the library on his own. A file containing only a \texttt{main} may then be compiled as long as the generated library path is specified.

So, {\br} doesn’t compile the file itself and, if its output is stored in a \texttt{a.rs} file, you can compile it with the following command:

\begin{verbatim}
$ rustc --crate-type=lib a.rs
\end{verbatim}

This will generate a \texttt{liba.rlib} file which can be included in other projects. The \texttt{rustc} command calls the Rust compiler; it can probably be installed separately, or from \texttt{rustup}, the official Rust toolchain installer. Anyway, this subject is outside the scope of this document.

The user may then want to write his own \texttt{main} function (so, in Rust), and bind it to the compiled library. If his file is \texttt{main.rs}, then, the command
\begin{verbatim}
$ rustc --extern a=liba.rlib main.rs
\end{verbatim}
will do the trick. Note, however, that a struct \texttt{struct} defined in the library needs to be referenced by the syntax \texttt{a::struct}.


\subsubsection{Specification}

All the following specifications must be respected. If they seem difficult to understand, and example is given in the section~\ref{specExample}.

\begin{enumerate}
\item Every call to a library's function \textit{must} follow the preconditions of the associated operation you may find in the abstract machine. No test is done automatically.
\item The only interface of the library you may use is the call to the functions. (Anyway, the Rust compiler should prevent any other access. Only the structure and its functions use the \texttt{pub} keyword.)
\item A call to any struct instance's function needs to be precedated by a call to the \texttt{initialisation} procedure.
\item A B operation called $f$ with the signature: $o_1, \cdots, o_n \leftarrow f(i_1, \cdots, i_m)$ is called with the syntax $f(i_1, \cdots, i_m, o_1, \cdots, o_n)$ (mind the order); however, input parameters need to be call by immutable reference to the associated Rust type and output parameters by mutable reference to the associated Rust type.
\end{enumerate}


\subsubsection{Recommandations}
\label{specExample}

Before using an operation of the component, instanciate the component (which is translated by a \texttt{struct} in Rust):

\begin{verbatim}
let mut s: component::component = Default::default();
\end{verbatim}

Note that:
\begin{enumerate}
\item The object has to be mutable (because the operation may modify the field of the struct);
\item \texttt{component} has to be replaced by the library’s name (the name of the compiled crate); hint: if the library is \texttt{libfoo.rlib}, it should be \texttt{foo};
\item The Rust struct (which matches a component) implements the \texttt{Default} trait, so, you may use the useful \texttt{default} function. As Rust refuses to call the \texttt{initialisation} if the object is not instaciated, it is even compulsory.
\end{enumerate}

Then, before doing anything, you \textit{must} run the initialisation:
\begin{verbatim}
s.initialisation();
\end{verbatim}

Now, if we want to call an operation with this signature:
\begin{verbatim}
o1, o2, o3 <-- op(i1, i2, i3) = PRE
    o1 : rust_i32 &
    o2 : rust_i8 &
    o3 : rust_i16 &
    i1 : rust_bool &
    i2 : rust_i8 &
    i3 : rust_i16
THEN
\end{verbatim}

The associated function \texttt{s.op} has six parameters matching the types specified in the specification; as the variable need to be instanciated first, your program might look like this:
\begin{verbatim}
let mut o1: i32 = 1234;
let mut o2: i8 = -67;
let mut o3: i16 = 0;
let i1: bool = false;
let i2: i8 = 12;
let i3: i16 = 0;
s.op(&i1, &i2, &i3, &mut o1, &mut o2, &mut o3);
\end{verbatim}

As Rust surprisingly accepts references to litterals, the latter code could also be written:

\begin{verbatim}
let mut o1: i32 = 1234;
let mut o2: i8 = -67;
let mut o3: i16 = 0;
s.op(&false, &12, &0, &mut o1, &mut o2, &mut o3);
\end{verbatim}



\subsection{Usage of generated file}
\label{usage}

The code {\br} generates is a library code; it doesn’t contain any \texttt{main} function. This allows the user to write his own \texttt{main}, either to specify the entry point of the program, or to test the library on his own. A file containing only a \texttt{main} may then be compiled as long as the generated library path is specified.

So, {\br} doesn’t compile the file itself and, if its output is stored in a \texttt{a.rs} file, you can compile it with the following command:

\begin{verbatim}
$ rustc --crate-type=lib a.rs
\end{verbatim}

This will generate a \texttt{liba.rlib} file which can be included in other projects. The \texttt{rustc} command calls the Rust compiler; it can probably be installed separately, or from \texttt{rustup}, the official Rust toolchain installer. Anyway, this subject is outside the scope of this document.

The user may then want to write his own \texttt{main} function (so, in Rust), and bind it to the compiled library. If his file is \texttt{main.rs}, then, the command
\begin{verbatim}
$ rustc --extern a=liba.rlib main.rs
\end{verbatim}
will do the trick. Note, however, that a struct \texttt{struct} defined in the library needs to be referenced by the syntax \texttt{a::struct}.

\subsubsection{Context}

The code {\br} generates is a library code; it doesn’t contain any \texttt{main} function. This allows the user to write his own \texttt{main}, which can be useful to specify the entry point of the program or to test the library on his own. A file containing only a \texttt{main} may then be compiled as long as the generated library path is specified.

So, {\br} doesn’t compile the file itself and, if its output is stored in a \texttt{a.rs} file, you can compile it with the following command:

\begin{verbatim}
$ rustc --crate-type=lib a.rs
\end{verbatim}

This will generate a \texttt{liba.rlib} file which can be included in other projects. The \texttt{rustc} command calls the Rust compiler; it can probably be installed separately, or from \texttt{rustup}, the official Rust toolchain installer. Anyway, this subject is outside the scope of this document.

The user may then want to write his own \texttt{main} function (so, in Rust), and bind it to the compiled library. If his file is \texttt{main.rs}, then, the command
\begin{verbatim}
$ rustc --extern a=liba.rlib main.rs
\end{verbatim}
will do the trick. Note, however, that a struct \texttt{struct} defined in the library needs to be referenced by the syntax \texttt{a::struct}.


\subsubsection{Specification}

All the following specifications must be respected. If they seem difficult to understand, and example is given in the section~\ref{specExample}.

\begin{enumerate}
\item Every call to a library's function \textit{must} follow the preconditions of the associated operation you may find in the abstract machine. No test is done automatically.
\item The only interface of the library you may use is the call to the functions. (Anyway, the Rust compiler should prevent any other access. Only the structure and its functions use the \texttt{pub} keyword.)
\item A call to any struct instance's function needs to be precedated by a call to the \texttt{initialisation} procedure.
\item A B operation called $f$ with the signature: $o_1, \cdots, o_n \leftarrow f(i_1, \cdots, i_m)$ is called with the syntax $f(i_1, \cdots, i_m, o_1, \cdots, o_n)$ (mind the order); however, input parameters need to be call by immutable reference to the associated Rust type and output parameters by mutable reference to the associated Rust type.
\end{enumerate}


\subsubsection{Recommandations}
\label{specExample}

Before using an operation of the component, instanciate the component (which is translated by a \texttt{struct} in Rust):

\begin{verbatim}
let mut s: component::component = Default::default();
\end{verbatim}

Note that:
\begin{enumerate}
\item The object has to be mutable (because the operation may modify the field of the struct);
\item \texttt{component} has to be replaced by the library’s name (the name of the compiled crate); hint: if the library is \texttt{libfoo.rlib}, it should be \texttt{foo};
\item The Rust struct (which matches a component) implements the \texttt{Default} trait, so, you may use the useful \texttt{default} function. As Rust refuses to call the \texttt{initialisation} if the object is not instaciated, it is even compulsory.
\end{enumerate}

Then, before doing anything, you \textit{must} run the initialisation:
\begin{verbatim}
s.initialisation();
\end{verbatim}

Now, if we want to call an operation with this signature:
\begin{verbatim}
o1, o2, o3 <-- op(i1, i2, i3) = PRE
    o1 : rust_i32 &
    o2 : rust_i8 &
    o3 : rust_i16 &
    i1 : rust_bool &
    i2 : rust_i8 &
    i3 : rust_i16
THEN
\end{verbatim}

The associated function \texttt{s.op} has six parameters matching the types specified in the specification; as the variable need to be instanciated first, your program might look like this:
\begin{verbatim}
let mut o1: i32 = 1234;
let mut o2: i8 = -67;
let mut o3: i16 = 0;
let i1: bool = false;
let i2: i8 = 12;
let i3: i16 = 0;
s.op(&i1, &i2, &i3, &mut o1, &mut o2, &mut o3);
\end{verbatim}

As Rust surprisingly accepts references to litterals, the latter code could also be written:

\begin{verbatim}
let mut o1: i32 = 1234;
let mut o2: i8 = -67;
let mut o3: i16 = 0;
s.op(&false, &12, &0, &mut o1, &mut o2, &mut o3);
\end{verbatim}

\subsubsection{Context}

The code {\br} generates (eventually made up of several files, if imported components) is a library code; it doesn’t contain any \texttt{main} function. This allows the user to write his own \texttt{main}, which can be useful to specify the entry point of the program or to test the library on his own. A file containing only a \texttt{main} may then be compiled as long as the generated library path is specified.

So, {\br} doesn’t compile the file itself and, if the code translation of the entry module is stored in a \texttt{a.rs} file, you can compile it with the following command:

\begin{verbatim}
$ rustc --crate-type=lib a.rs
\end{verbatim}

This will generate a \texttt{liba.rlib} file which can be included in other projects. The \texttt{rustc} command calls the Rust compiler; it can probably be installed separately, or from \texttt{rustup}, the official Rust toolchain installer. Anyway, this subject is outside the scope of this document.

The user may then want to write his own \texttt{main} function (so, in Rust), and bind it to the compiled library. If his file is \texttt{main.rs}, then, the command
\begin{verbatim}
$ rustc --extern a=liba.rlib main.rs
\end{verbatim}
will do the trick. Note, however, that a struct \texttt{struct} defined in the library needs to be referenced by the syntax \texttt{a::struct}.

If your project uses recursively imported modules, the latter commands are sufficient, as long as the other component code translations are in the same directory as \texttt{a.rs}.


\subsubsection{Specification}

All the following specifications must be respected. If they seem difficult to understand, and example is given in the section~\ref{specExample}.

\begin{enumerate}
\item Every call to a library's function \textit{must} follow the preconditions of the associated operation you may find in the abstract machine. No test is done automatically.
\item The only interface of the library you may use is the call to the functions. (Anyway, the Rust compiler should prevent any other access.)
\item A call to any struct instance's function needs to be preceded by a call to the \texttt{initialisation} procedure.
\item A B operation called $f$ with the signature: $o_1, \cdots, o_n \leftarrow f(i_1, \cdots, i_m)$ is called with the syntax $f(i_1, \cdots, i_m, o_1, \cdots, o_n)$ (mind the order); however, input parameters need to be call by immutable reference to the associated Rust type and output parameters by mutable reference to the associated Rust type.
\end{enumerate}


\subsubsection{Recommandations}
\label{specExample}

Before using an operation of the component, instanciate the component (which is translated by a \texttt{struct} in Rust):

\begin{verbatim}
let mut s: component::component = Default::default();
\end{verbatim}

Note that:
\begin{enumerate}
\item The object has to be mutable (because the operation may modify the field of the struct);
\item \texttt{component} has to be replaced by the library’s name (the name of the compiled crate); hint: if the library is \texttt{libfoo.rlib}, it should be \texttt{foo};
\item The Rust struct (which matches a component) implements the \texttt{Default} trait, so, you may use the useful \texttt{default} function. As Rust refuses to call the \texttt{initialisation} if the object is not instaciated, it is even compulsory.
\end{enumerate}

Then, before doing anything, you \textit{must} run the initialisation:
\begin{verbatim}
s.initialisation();
\end{verbatim}

Now, if we want to call an operation with this signature:
\begin{verbatim}
o1, o2, o3 <-- op(i1, i2, i3) = PRE
    o1 : rust_i32 &
    o2 : rust_i8 &
    o3 : rust_i16 &
    i1 : rust_bool &
    i2 : rust_i8 &
    i3 : rust_i16
THEN
\end{verbatim}

The associated function \texttt{s.op} has six parameters matching the types specified in the specification; as the variable need to be instanciated first, your program might look like this:
\begin{verbatim}
let mut o1: i32 = 1234;
let mut o2: i8 = -67;
let mut o3: i16 = 0;
let i1: bool = false;
let i2: i8 = 12;
let i3: i16 = 0;
s.op(&i1, &i2, &i3, &mut o1, &mut o2, &mut o3);
\end{verbatim}

As Rust surprisingly accepts references to litterals, the latter code could also be written:

\begin{verbatim}
let mut o1: i32 = 1234;
let mut o2: i8 = -67;
let mut o3: i16 = 0;
s.op(&false, &12, &0, &mut o1, &mut o2, &mut o3);
\end{verbatim}

\subsubsection{Context}

The code {\br} generates (eventually made up of several files, if imported components) is a library code; it doesn’t contain any \texttt{main} function. This allows the user to write his own \texttt{main}, which can be useful to specify the entry point of the program or to test the library on his own. A file containing only a \texttt{main} may then be compiled as long as the generated library path is specified.

So, {\br} doesn’t compile the file itself and, if the code translation of the entry module is stored in a \texttt{a.rs} file, you can compile it with the following command:

\begin{verbatim}
$ rustc --crate-type=lib a.rs
\end{verbatim}

This will generate a \texttt{liba.rlib} file which can be included in other projects. The \texttt{rustc} command calls the Rust compiler; it can probably be installed separately, or from \texttt{rustup}, the official Rust toolchain installer. Anyway, this subject is outside the scope of this document.

The user may then want to write his own \texttt{main} function (so, in Rust), and bind it to the compiled library. If his file is \texttt{main.rs}, then, the command
\begin{verbatim}
$ rustc --extern a=liba.rlib main.rs
\end{verbatim}
will do the trick. Note, however, that a struct \texttt{struct} defined in the library needs to be referenced by the syntax \texttt{a::struct}.

If your project uses recursively imported modules, the latter commands are sufficient, as long as the other component code translations are in the same directory as \texttt{a.rs}.


\subsubsection{Specification}

All the following specifications must be respected. If they seem difficult to understand, and example is given in the section~\ref{specExample}.

\begin{enumerate}
\item Every call to a library's function \textit{must} follow the preconditions of the associated operation you may find in the abstract machine. No test is done automatically.
\item The only interface of the library you may use is the call to the functions. (Anyway, the Rust compiler should prevent any other access.)
\item A call to any struct instance's function needs to be preceded by a call to the \texttt{initialisation} procedure.
\item A B operation called $f$ with the signature: $o_1, \cdots, o_n \leftarrow f(i_1, \cdots, i_m)$ is called with the syntax $f(i_1, \cdots, i_m, o_1, \cdots, o_n)$ (mind the order); however, input parameters need to be call by immutable reference to the associated Rust type and output parameters by mutable reference to the associated Rust type.
\end{enumerate}


\subsubsection{Recommandations}
\label{specExample}

Before using an operation of the component, instanciate the component (which is translated by a \texttt{struct} in Rust):

\begin{verbatim}
let mut s: component::component = Default::default();
\end{verbatim}

Note that:
\begin{enumerate}
\item The object has to be mutable (because the operation may modify the field of the struct);
\item \texttt{component} has to be replaced by the library’s name (the name of the compiled crate); hint: if the library is \texttt{libfoo.rlib}, it should be \texttt{foo};
\item The Rust struct (which matches a component) implements the \texttt{Default} trait, so, you may use the useful \texttt{default} function. As Rust refuses to call the \texttt{initialisation} if the object is not instaciated, it is even compulsory.
\end{enumerate}

Then, before doing anything, you \textit{must} run the initialisation:
\begin{verbatim}
s.initialisation();
\end{verbatim}

Now, if we want to call an operation with this signature:
\begin{verbatim}
o1, o2, o3 <-- op(i1, i2, i3) = PRE
    o1 : rust_i32 &
    o2 : rust_i8 &
    o3 : rust_i16 &
    i1 : rust_bool &
    i2 : rust_i8 &
    i3 : rust_i16
THEN
\end{verbatim}

The associated function \texttt{s.op} has six parameters matching the types specified in the specification; as the variable need to be instanciated first, your program might look like this:
\begin{verbatim}
let mut o1: i32 = 1234;
let mut o2: i8 = -67;
let mut o3: i16 = 0;
let i1: bool = false;
let i2: i8 = 12;
let i3: i16 = 0;
s.op(&i1, &i2, &i3, &mut o1, &mut o2, &mut o3);
\end{verbatim}

As Rust surprisingly accepts references to litterals, the latter code could also be written:

\begin{verbatim}
let mut o1: i32 = 1234;
let mut o2: i8 = -67;
let mut o3: i16 = 0;
s.op(&false, &12, &0, &mut o1, &mut o2, &mut o3);
\end{verbatim}

\subsubsection{Context}

The code {\br} generates (eventually made up of several files, if imported components) is a library code; it doesn’t contain any \texttt{main} function. This allows the user to write his own \texttt{main}, which can be useful to specify the entry point of the program or to test the library on his own. A file containing only a \texttt{main} may then be compiled as long as the generated library path is specified.

So, {\br} doesn’t compile the file itself and, if the code translation of the entry module is stored in a \texttt{a.rs} file, you can compile it with the following command:

\begin{verbatim}
$ rustc --crate-type=lib a.rs
\end{verbatim}

This will generate a \texttt{liba.rlib} file which can be included in other projects. The \texttt{rustc} command calls the Rust compiler; it can probably be installed separately, or from \texttt{rustup}, the official Rust toolchain installer. Anyway, this subject is outside the scope of this document.

The user may then want to write his own \texttt{main} function (so, in Rust), and bind it to the compiled library. If his file is \texttt{main.rs}, then, the command
\begin{verbatim}
$ rustc --extern a=liba.rlib main.rs
\end{verbatim}
will do the trick. Note, however, that a struct \texttt{struct} defined in the library needs to be referenced by the syntax \texttt{a::struct}.

If your project uses recursively imported modules, the latter commands are sufficient, as long as the other component code translations are in the same directory as \texttt{a.rs}.


\subsubsection{Specification}

All the following specifications must be respected. If they seem difficult to understand, and example is given in the section~\ref{specExample}.

\begin{enumerate}
\item Every call to a library's function \textit{must} follow the preconditions of the associated operation you may find in the abstract machine. No test is done automatically.
\item The only interface of the library you may use is the call to the functions. (Anyway, the Rust compiler should prevent any other access.)
\item A call to any struct instance's function needs to be preceded by a call to the \texttt{initialisation} procedure.
\item A B operation called $f$ with the signature: $o_1, \cdots, o_n \leftarrow f(i_1, \cdots, i_m)$ is called with the syntax $f(i_1, \cdots, i_m, o_1, \cdots, o_n)$ (mind the order); however, input parameters need to be call by immutable reference to the associated Rust type and output parameters by mutable reference to the associated Rust type.
\end{enumerate}


\subsubsection{Recommandations}
\label{specExample}

Before using an operation of the component, instanciate the component (which is translated by a \texttt{struct} in Rust):

\begin{verbatim}
let mut s: component::component = Default::default();
\end{verbatim}

Note that:
\begin{enumerate}
\item The object has to be mutable (because the operation may modify the field of the struct);
\item \texttt{component} has to be replaced by the library’s name (the name of the compiled crate); hint: if the library is \texttt{libfoo.rlib}, it should be \texttt{foo};
\item The Rust struct (which matches a component) implements the \texttt{Default} trait, so, you may use the useful \texttt{default} function. As Rust refuses to call the \texttt{initialisation} if the object is not instaciated, it is even compulsory.
\end{enumerate}

Then, before doing anything, you \textit{must} run the initialisation:
\begin{verbatim}
s.initialisation();
\end{verbatim}

Now, if we want to call an operation with this signature:
\begin{verbatim}
o1, o2, o3 <-- op(i1, i2, i3) = PRE
    o1 : rust_i32 &
    o2 : rust_i8 &
    o3 : rust_i16 &
    i1 : rust_bool &
    i2 : rust_i8 &
    i3 : rust_i16
THEN
\end{verbatim}

The associated function \texttt{s.op} has six parameters matching the types specified in the specification; as the variable need to be instanciated first, your program might look like this:
\begin{verbatim}
let mut o1: i32 = 1234;
let mut o2: i8 = -67;
let mut o3: i16 = 0;
let i1: bool = false;
let i2: i8 = 12;
let i3: i16 = 0;
s.op(&i1, &i2, &i3, &mut o1, &mut o2, &mut o3);
\end{verbatim}

As Rust surprisingly accepts references to litterals, the latter code could also be written:

\begin{verbatim}
let mut o1: i32 = 1234;
let mut o2: i8 = -67;
let mut o3: i16 = 0;
s.op(&false, &12, &0, &mut o1, &mut o2, &mut o3);
\end{verbatim}

\subsubsection{Context}

The code {\br} generates (eventually made up of several files, if imported components) is a library code; it doesn’t contain any \texttt{main} function. This allows the user to write his own \texttt{main}, which can be useful to specify the entry point of the program or to test the library on his own. A file containing only a \texttt{main} may then be compiled as long as the generated library path is specified.

So, {\br} doesn’t compile the file itself and, if the code translation of the entry module is stored in a \texttt{a.rs} file, you can compile it with the following command:

\begin{verbatim}
$ rustc --crate-type=lib a.rs
\end{verbatim}

This will generate a \texttt{liba.rlib} file which can be included in other projects. The \texttt{rustc} command calls the Rust compiler; it can probably be installed separately, or from \texttt{rustup}, the official Rust toolchain installer. Anyway, this subject is outside the scope of this document.

The user may then want to write his own \texttt{main} function (so, in Rust), and bind it to the compiled library. If his file is \texttt{main.rs}, then, the command
\begin{verbatim}
$ rustc --extern a=liba.rlib main.rs
\end{verbatim}
will do the trick. Note, however, that a struct \texttt{struct} defined in the library needs to be referenced by the syntax \texttt{a::struct}.

If your project uses recursively imported modules, the latter commands are sufficient, as long as the other component code translations are in the same directory as \texttt{a.rs}.


\subsubsection{Specification}

All the following specifications must be respected. If they seem difficult to understand, and example is given in the section~\ref{specExample}.

\begin{enumerate}
\item Every call to a library's function \textit{must} follow the preconditions of the associated operation you may find in the abstract machine. No test is done automatically.
\item The only interface of the library you may use is the call to the functions. (Anyway, the Rust compiler should prevent any other access.)
\item A call to any struct instance's function needs to be preceded by a call to the \texttt{initialisation} procedure.
\item A B operation called $f$ with the signature: $o_1, \cdots, o_n \leftarrow f(i_1, \cdots, i_m)$ is called with the syntax $f(i_1, \cdots, i_m, o_1, \cdots, o_n)$ (mind the order); however, input parameters need to be call by immutable reference to the associated Rust type and output parameters by mutable reference to the associated Rust type.
\end{enumerate}


\subsubsection{Recommandations}
\label{specExample}

Before using an operation of the component, instanciate the component (which is translated by a \texttt{struct} in Rust):

\begin{verbatim}
let mut s: component::component = Default::default();
\end{verbatim}

Note that:
\begin{enumerate}
\item The object has to be mutable (because the operation may modify the field of the struct);
\item \texttt{component} has to be replaced by the library’s name (the name of the compiled crate); hint: if the library is \texttt{libfoo.rlib}, it should be \texttt{foo};
\item The Rust struct (which matches a component) implements the \texttt{Default} trait, so, you may use the useful \texttt{default} function. As Rust refuses to call the \texttt{initialisation} if the object is not instaciated, it is even compulsory.
\end{enumerate}

Then, before doing anything, you \textit{must} run the initialisation:
\begin{verbatim}
s.initialisation();
\end{verbatim}

Now, if we want to call an operation with this signature:
\begin{verbatim}
o1, o2, o3 <-- op(i1, i2, i3) = PRE
    o1 : rust_i32 &
    o2 : rust_i8 &
    o3 : rust_i16 &
    i1 : rust_bool &
    i2 : rust_i8 &
    i3 : rust_i16
THEN
\end{verbatim}

The associated function \texttt{s.op} has six parameters matching the types specified in the specification; as the variable need to be instanciated first, your program might look like this:
\begin{verbatim}
let mut o1: i32 = 1234;
let mut o2: i8 = -67;
let mut o3: i16 = 0;
let i1: bool = false;
let i2: i8 = 12;
let i3: i16 = 0;
s.op(&i1, &i2, &i3, &mut o1, &mut o2, &mut o3);
\end{verbatim}

As Rust surprisingly accepts references to litterals, the latter code could also be written:

\begin{verbatim}
let mut o1: i32 = 1234;
let mut o2: i8 = -67;
let mut o3: i16 = 0;
s.op(&false, &12, &0, &mut o1, &mut o2, &mut o3);
\end{verbatim}

\subsubsection{Context}

The code {\br} generates (eventually made up of several files, if imported components) is a library code; it doesn’t contain any \texttt{main} function. This allows the user to write his own \texttt{main}, which can be useful to specify the entry point of the program or to test the library on his own. A file containing only a \texttt{main} may then be compiled as long as the generated library path is specified.

So, {\br} doesn’t compile the file itself and, if the code translation of the entry module is stored in a \texttt{a.rs} file, you can compile it with the following command:

\begin{verbatim}
$ rustc --crate-type=lib a.rs
\end{verbatim}

This will generate a \texttt{liba.rlib} file which can be included in other projects. The \texttt{rustc} command calls the Rust compiler; it can probably be installed separately, or from \texttt{rustup}, the official Rust toolchain installer. Anyway, this subject is outside the scope of this document.

The user may then want to write his own \texttt{main} function (so, in Rust), and bind it to the compiled library. If his file is \texttt{main.rs}, then, the command
\begin{verbatim}
$ rustc --extern a=liba.rlib main.rs
\end{verbatim}
will do the trick. Note, however, that a struct \texttt{struct} defined in the library needs to be referenced by the syntax \texttt{a::struct}.

If your project uses recursively imported modules, the latter commands are sufficient, as long as the other component code translations are in the same directory as \texttt{a.rs}.


\subsubsection{Specification}

All the following specifications must be respected. If they seem difficult to understand, and example is given in the section~\ref{specExample}.

\begin{enumerate}
\item Every call to a library's function \textit{must} follow the preconditions of the associated operation you may find in the abstract machine. No test is done automatically.
\item The only interface of the library you may use is the call to the functions. (Anyway, the Rust compiler should prevent any other access.)
\item A call to any struct instance's function needs to be preceded by a call to the \texttt{initialisation} procedure.
\item A B operation called $f$ with the signature: $o_1, \cdots, o_n \leftarrow f(i_1, \cdots, i_m)$ is called with the syntax $f(i_1, \cdots, i_m, o_1, \cdots, o_n)$ (mind the order); however, input parameters need to be call by immutable reference to the associated Rust type and output parameters by mutable reference to the associated Rust type.
\end{enumerate}


\subsubsection{Recommandations}
\label{specExample}

Before using an operation of the component, instanciate the component (which is translated by a \texttt{struct} in Rust):

\begin{verbatim}
let mut s: component::component = Default::default();
\end{verbatim}

Note that:
\begin{enumerate}
\item The object has to be mutable (because the operation may modify the field of the struct);
\item \texttt{component} has to be replaced by the library’s name (the name of the compiled crate); hint: if the library is \texttt{libfoo.rlib}, it should be \texttt{foo};
\item The Rust struct (which matches a component) implements the \texttt{Default} trait, so, you may use the useful \texttt{default} function. As Rust refuses to call the \texttt{initialisation} if the object is not instaciated, it is even compulsory.
\end{enumerate}

Then, before doing anything, you \textit{must} run the initialisation:
\begin{verbatim}
s.initialisation();
\end{verbatim}

Now, if we want to call an operation with this signature:
\begin{verbatim}
o1, o2, o3 <-- op(i1, i2, i3) = PRE
    o1 : rust_i32 &
    o2 : rust_i8 &
    o3 : rust_i16 &
    i1 : rust_bool &
    i2 : rust_i8 &
    i3 : rust_i16
THEN
\end{verbatim}

The associated function \texttt{s.op} has six parameters matching the types specified in the specification; as the variable need to be instanciated first, your program might look like this:
\begin{verbatim}
let mut o1: i32 = 1234;
let mut o2: i8 = -67;
let mut o3: i16 = 0;
let i1: bool = false;
let i2: i8 = 12;
let i3: i16 = 0;
s.op(&i1, &i2, &i3, &mut o1, &mut o2, &mut o3);
\end{verbatim}

As Rust surprisingly accepts references to litterals, the latter code could also be written:

\begin{verbatim}
let mut o1: i32 = 1234;
let mut o2: i8 = -67;
let mut o3: i16 = 0;
s.op(&false, &12, &0, &mut o1, &mut o2, &mut o3);
\end{verbatim}

\subsubsection{Context}

The code {\br} generates (eventually made up of several files, if imported components) is a library code; it doesn’t contain any \texttt{main} function. This allows the user to write his own \texttt{main}, which can be useful to specify the entry point of the program or to test the library on his own. A file containing only a \texttt{main} may then be compiled as long as the generated library path is specified.

So, {\br} doesn’t compile the file itself and, if the code translation of the entry module is stored in a \texttt{a.rs} file, you can compile it with the following command:

\begin{verbatim}
$ rustc --crate-type=lib a.rs
\end{verbatim}

This will generate a \texttt{liba.rlib} file which can be included in other projects. The \texttt{rustc} command calls the Rust compiler; it can probably be installed separately, or from \texttt{rustup}, the official Rust toolchain installer. Anyway, this subject is outside the scope of this document.

The user may then want to write his own \texttt{main} function (so, in Rust), and bind it to the compiled library. If his file is \texttt{main.rs}, then, the command
\begin{verbatim}
$ rustc --extern a=liba.rlib main.rs
\end{verbatim}
will do the trick. Note, however, that a struct \texttt{struct} defined in the library needs to be referenced by the syntax \texttt{a::struct}.

If your project uses recursively imported modules, the latter commands are sufficient, as long as the other component code translations are in the same directory as \texttt{a.rs}.


\subsubsection{Specification}

All the following specifications must be respected. If they seem difficult to understand, and example is given in the section~\ref{specExample}.

\begin{enumerate}
\item Every call to a library's function \textit{must} follow the preconditions of the associated operation you may find in the abstract machine. No test is done automatically.
\item The only interface of the library you may use is the call to the functions. (Anyway, the Rust compiler should prevent any other access.)
\item A call to any struct instance's function needs to be preceded by a call to the \texttt{initialisation} procedure.
\item A B operation called $f$ with the signature: $o_1, \cdots, o_n \leftarrow f(i_1, \cdots, i_m)$ is called with the syntax $f(i_1, \cdots, i_m, o_1, \cdots, o_n)$ (mind the order); however, input parameters need to be call by immutable reference to the associated Rust type and output parameters by mutable reference to the associated Rust type.
\end{enumerate}


\subsubsection{Recommandations}
\label{specExample}

Before using an operation of the component, instanciate the component (which is translated by a \texttt{struct} in Rust):

\begin{verbatim}
let mut s: component::component = Default::default();
\end{verbatim}

Note that:
\begin{enumerate}
\item The object has to be mutable (because the operation may modify the field of the struct);
\item \texttt{component} has to be replaced by the library’s name (the name of the compiled crate); hint: if the library is \texttt{libfoo.rlib}, it should be \texttt{foo};
\item The Rust struct (which matches a component) implements the \texttt{Default} trait, so, you may use the useful \texttt{default} function. As Rust refuses to call the \texttt{initialisation} if the object is not instaciated, it is even compulsory.
\end{enumerate}

Then, before doing anything, you \textit{must} run the initialisation:
\begin{verbatim}
s.initialisation();
\end{verbatim}

Now, if we want to call an operation with this signature:
\begin{verbatim}
o1, o2, o3 <-- op(i1, i2, i3) = PRE
    o1 : rust_i32 &
    o2 : rust_i8 &
    o3 : rust_i16 &
    i1 : rust_bool &
    i2 : rust_i8 &
    i3 : rust_i16
THEN
\end{verbatim}

The associated function \texttt{s.op} has six parameters matching the types specified in the specification; as the variable need to be instanciated first, your program might look like this:
\begin{verbatim}
let mut o1: i32 = 1234;
let mut o2: i8 = -67;
let mut o3: i16 = 0;
let i1: bool = false;
let i2: i8 = 12;
let i3: i16 = 0;
s.op(&i1, &i2, &i3, &mut o1, &mut o2, &mut o3);
\end{verbatim}

As Rust surprisingly accepts references to litterals, the latter code could also be written:

\begin{verbatim}
let mut o1: i32 = 1234;
let mut o2: i8 = -67;
let mut o3: i16 = 0;
s.op(&false, &12, &0, &mut o1, &mut o2, &mut o3);
\end{verbatim}

\subsubsection{Context}

The code {\br} generates (eventually made up of several files, if imported components) is a library code; it doesn’t contain any \texttt{main} function. This allows the user to write his own \texttt{main}, which can be useful to specify the entry point of the program or to test the library on his own. A file containing only a \texttt{main} may then be compiled as long as the generated library path is specified.

So, {\br} doesn’t compile the file itself and, if the code translation of the entry module is stored in a \texttt{a.rs} file, you can compile it with the following command:

\begin{verbatim}
$ rustc --crate-type=lib a.rs
\end{verbatim}

This will generate a \texttt{liba.rlib} file which can be included in other projects. The \texttt{rustc} command calls the Rust compiler; it can probably be installed separately, or from \texttt{rustup}, the official Rust toolchain installer. Anyway, this subject is outside the scope of this document.

The user may then want to write his own \texttt{main} function (so, in Rust), and bind it to the compiled library. If his file is \texttt{main.rs}, then, the command
\begin{verbatim}
$ rustc --extern a=liba.rlib main.rs
\end{verbatim}
will do the trick. Note, however, that a struct \texttt{struct} defined in the library needs to be referenced by the syntax \texttt{a::struct}.

If your project uses recursively imported modules, the latter commands are sufficient, as long as the other component code translations are in the same directory as \texttt{a.rs}.


\subsubsection{Specification}

All the following specifications must be respected. If they seem difficult to understand, and example is given in the section~\ref{specExample}.

\begin{enumerate}
\item Every call to a library's function \textit{must} follow the preconditions of the associated operation you may find in the abstract machine. No test is done automatically.
\item The only interface of the library you may use is the call to the functions. (Anyway, the Rust compiler should prevent any other access.)
\item A call to any struct instance's function needs to be preceded by a call to the \texttt{initialisation} procedure.
\item A B operation called $f$ with the signature: $o_1, \cdots, o_n \leftarrow f(i_1, \cdots, i_m)$ is called with the syntax $f(i_1, \cdots, i_m, o_1, \cdots, o_n)$ (mind the order); however, input parameters need to be call by immutable reference to the associated Rust type and output parameters by mutable reference to the associated Rust type.
\end{enumerate}


\subsubsection{Recommandations}
\label{specExample}

Before using an operation of the component, instanciate the component (which is translated by a \texttt{struct} in Rust):

\begin{verbatim}
let mut s: component::component = Default::default();
\end{verbatim}

Note that:
\begin{enumerate}
\item The object has to be mutable (because the operation may modify the field of the struct);
\item \texttt{component} has to be replaced by the library’s name (the name of the compiled crate); hint: if the library is \texttt{libfoo.rlib}, it should be \texttt{foo};
\item The Rust struct (which matches a component) implements the \texttt{Default} trait, so, you may use the useful \texttt{default} function. As Rust refuses to call the \texttt{initialisation} if the object is not instaciated, it is even compulsory.
\end{enumerate}

Then, before doing anything, you \textit{must} run the initialisation:
\begin{verbatim}
s.initialisation();
\end{verbatim}

Now, if we want to call an operation with this signature:
\begin{verbatim}
o1, o2, o3 <-- op(i1, i2, i3) = PRE
    o1 : rust_i32 &
    o2 : rust_i8 &
    o3 : rust_i16 &
    i1 : rust_bool &
    i2 : rust_i8 &
    i3 : rust_i16
THEN
\end{verbatim}

The associated function \texttt{s.op} has six parameters matching the types specified in the specification; as the variable need to be instanciated first, your program might look like this:
\begin{verbatim}
let mut o1: i32 = 1234;
let mut o2: i8 = -67;
let mut o3: i16 = 0;
let i1: bool = false;
let i2: i8 = 12;
let i3: i16 = 0;
s.op(&i1, &i2, &i3, &mut o1, &mut o2, &mut o3);
\end{verbatim}

As Rust surprisingly accepts references to litterals, the latter code could also be written:

\begin{verbatim}
let mut o1: i32 = 1234;
let mut o2: i8 = -67;
let mut o3: i16 = 0;
s.op(&false, &12, &0, &mut o1, &mut o2, &mut o3);
\end{verbatim}


\section{Application field of {\br}}
\label{subset}

Let us define $\mathsf{directory}_i, \mathsf{directory}_o, \mathsf{module}$ three characters strings
% TODO_16 really? A string? See UNIX/POSIX calling options.
given as parameter to {\br} (for example, with the call \texttt{b2rust -I $\mathsf{directory}_i$ -O $\mathsf{directory}_o$ $\mathsf{module}$}). It is the goal of this section to explicit the requirements $\mathsf{directory}_i, \mathsf{directory}_o, \mathsf{module}$ need to meet in order to allow {\br} to generate a correct code, {\ie} a Rust code usable by a final user without errors (but, concerning the Rust compilation, not necessarily without warnings) like specified section~\ref{usage}, and which matches the specification of the B~programs.

% If these strings are correct, {\br} will consider the file, \texttt{$\mathsf{directory}_i$/$\mathsf{module}$.bxml} and \texttt{$\mathsf{directory}_i$/$\mathsf{module}$\_i.bxml},

The requirements are:
\begin{enumerate}
\item $\mathsf{directory}_i$ has to be a path to an existing directory in the filesystem and {\br} needs to have execution permissions on it (so that it can read its files);
\item \label{recursionBegining} The files $e_a \coloneq \mathtt{\mathsf{directory}_i/\mathsf{module}.bxml}$ and $e_i \coloneq \mathtt{\mathsf{directory}_i/\mathsf{module}\_i.bxml}$ have to be existing files of the filesystem, and {\br} needs to have read access to $e_a$ and $e_i$.
\item $e_a$ and $e_i$ must be BXML~1.0 compliant files.
\item $e_a$ has to be an abstract machine.
\item $e_i$ has to be the implementation of $e_a$.
\item \label{recursionBeforeNext} Atelier~B must be able to prove the $e_a$ and $e_i$ components.
\item $e_i$ has to respect the "modules requirements" you can find section~\ref{moduleSubset}.
\end{enumerate}

Before giving the next requirement, let us define $i_1, \cdots, i_n$ the characters strings which represent the machines imported by $e_i$. If there are none, $n = 0$. If $e_i$ is associated to a B~program which contains the following lines:

\noindent
\begin{verbatim}
IMPORTS
    M1.module01,
    module03
    M2.module01,
    M3.module02
\end{verbatim}

\noindent
, then, $n = 4$ and $i_1 = \mathtt{module01}$, $i_2 = \mathtt{module03}$, $i_3 = i_1$ and $i_4 = \mathtt{module02}$.

\begin{enumerate}[resume]
\item \label{recursionEnd}For any $k \in \{1, \cdots, n\}$, the requirements~\ref{recursionBegining} to~\ref{recursionEnd} also apply if you replace $e_a$ and $e_i$ by $i_{k, a} \coloneq \mathtt{\mathsf{directory}_i/}i_k\mathtt{.bxml}$ and $i_{k, i} \coloneq \mathtt{\mathsf{directory}_i/}i_k\mathtt{\_i.bxml}$. (This also applies to the definition of sub-imports used in requirement~\ref{recursionEnd}, so, they apply to recursively imported modules.)
\item The Atelier~B project which has $(e_a, e_i)$ as entry module must be checked by the "Project checker".
\end{enumerate}

\noindent
\fbox{\parbox{\textwidth}{
    For reasons which have not been yet fully understood, some nested expressions using maths operators and especially assignements are not well translated by {\br}. It might be because B authorizes assignements from 32-bits integer to 8-bits integer, for example, but Rust doesn’t. Anyway~--- it should be corrected. Some tests fail and highlight this problem.
    }
}



\subsection{Modules requirements}
\label{moduleSubset}

Let us consider two standard BXML~1.0 files we call $a'$ and $i'$ which match the requirements \ref{recursionBegining} to \ref{recursionBeforeNext} of the \hyperref[subset]{last section}. They match B~programs we call respectively $a$ and $i$.

Let us define requirements $a$ and $i$ could respect:
\begin{enumerate}[label={\protect\circled{$\mathcal{R}_\arabic*$}}]
\item[allo] $i$ is the implementation of $a$;
\item $i$ doesn't \texttt{SEES}, \texttt{INCLUDE}, \texttt{EXTENDS}, \texttt{USES} any other components, \textbf{except} \texttt{b2rust\_types}, a file you can find in the \texttt{files/} directory and which defines the types {\br} recognizes.
\item $i$ matches the grammar $\mathcal{G}_i$ whose definition follows:
  \begin{align*}
    \mathcal{G}_i = & \rtext{IMPLEMENTATION}   \gramN{Ident} \rtext{\_i}   \\
                    & \rtext{REFINES}   \gramN{Ident}   \\
                    & \rtext{SEES}   \rtext{b2rust\_types}   \\
                    & \gram{ClauseImplantation'} \*   \\
                    & \rtext{END}
  \end{align*}
  (The definition of \gram{ClauseImplantation'} is given \hyperlink{grammar}{later}.)
\item For each concrete constant we call $c$ ($c$ is a characters string) defined somewhere among the components, the \texttt{PROPERTIES} clause of $i$ has to contain a $\gramN{Prédicat}$ under the shape
  \[
    c   \: \rtext{:}   \: \gram{RecognizedType}
  \]
\item For each concrete variable we call $v$ ($v$ is a characters string) defined somewhere among the components, the \texttt{INVARIANT} clause of $i$ has to contain a $\gramN{Prédicat}$ under the shape
  \[
    v   \: \rtext{:}   \: \gram{RecognizedType}
  \]
\item \label{varinbecomesin} For each usage of a \gram{LocalVariableInstruction}, the introduced local variables have to be typed using a \gram{RecognizedType} in the nested instructions using a \gram{Substitution\_devient\_elt\_de'} instruction. More precisely, if a local variable instruction introduces $n$ new variables whose names are $v_1, \cdots, v_n$, then:
  \begin{enumerate}
  \item It needs to have at least $n$ nested instructions.
  \item \label{loca}The first $n$ nested instructions must follow the shape of \gram{SubstitutionDevientEltDe'}, where the \gram{Ident} is exactly the name of a declared local variable.
  \item Each declared local variable must be typed this way. As a consequence of~\ref{loca} and \ref{locb}, each declared local variable must be typed exactly once this way.
  \end{enumerate}
\item \label{locb} Outside the circumstances defined under proposition~\ref{varinbecomesin}, usage of the \gram{SubstitutionDevientEltDe'} is forbidden.
\item For each operation of $i$, if we call $n$ its number of input parameters and $m$ its number of output parameters, then, if $n+m \geq 1$:
  \begin{enumerate}
  \item The abstraction of the operation must have a precondition.
  \item This precondition must be under the shape $p_1 \rtext{\&} p_2 \rtext{\&} \cdots \rtext{\&} p_p$ (we might also have $p = 1$).
  \item For each input or output parameter named $s$\footnote{Reminder: according to the B~reference, the parameters name are the same between a machine's operation and its implementation.}, there must be exactly one predicate among $p_1, \cdots, p_p$ under the shape $s \: \rtext{:} \: \gram{RecognizedType}$. (So, do not type twice a parameter, even if these typings are not mutually exclusive. However, you may write $s \rtext{: INT}$, and, later on, $s \rtext{: rust\_i32}$, for example.)
  \end{enumerate}
\end{enumerate}

\hypertarget{grammar}{The grammar $\mathcal{G}_i$ definition uses other grammars we give the definition below. They use explicit names (they correspond to known B clause names or known computer science entities), so we shall take the opportunity to explain precisely the subset of B0 {\br} translates.}

To give the user clear information about the translation scope of {\br} from the point of view of B0, the B0 grammar recognition (given in the document \textit{Manuel de référence du langage~B}, but some terms are translated into English below) is specified on the left column in the following definitions. On the right, you can find the {\br} recognized grammar.

The grammar uses a syntax which heavily relies one regular expressions (\textit{regexps}). In the following examples, $e$ and $f$ are regexps.
\begin{itemize}
\item \rtext{hello{\textbackslash}1243\_?\{[} matches exactly the character string \texttt{hello{\textbackslash}1234\_?\{[};
\item A regular expression can be stored into a constant which is typeset with a sans serif font, in blue, and underlined, \gram{like this}; if you read a numerized version of this document, it also creates a link to the definition (which is non valid in our example, but here is a valid version: \gram{ClauseInitialisationB0}). A grey typeset (\gramN{like this}) just means it is a blind syntax, {\ie} it is not defined in the document and it has no link;
\item $e\cdot f$ matches exactly $e$ followed by $f$ (when possible, the dot is omitted);
\item $e \mid f$ matches exactly $e$ and $f$;
\item $e+$ mateches exactly $e$ or $ee$ or $eee$, etc. In other terms, it matches the $e$ regexp repeated anytime. Note that regexp can be aggregated using parenteses, like usual mathematical expressions;
\item $e+^f$ matches $e$ or $efe$ or $efefe$, etc. In other terms, it matches the $e$ regexp repeated anytime, but using $f$ as separator;
\item $e*$ is the same as $e+$, but it also matches nothing (\ie the empty string characters). $e*^f$ is defined the same way;
\item $e?$ matches $e$ and nothing;
\item $[\rtext{a}-\rtext{b}]$ matches any character \textit{between} $\rtext{a}$ and $\rtext{b}$, if this has any sense; it works only with digits (for example, $[\rtext{2}-\rtext{9}]$ matches $\rtext{2}$, $\rtext{3}$, etc., $\rtext{9}$) and letters ($[\rtext{A}-\rtext{C}]$ matches $\rtext{A}$, $\rtext{B}$, $\rtext{C}$, $[\rtext{u}-\rtext{w}]$ matches $\rtext{u}$, $\rtext{v}$, $\rtext{w}$).
  % Maybe useless. No: likely useless.
% \item $\nrs$ matches at least one whitespace (so, a newline, a space, a no-break space, etc.);
% \item $\rs = \nrs?$, so, it matches at least one whitespace, or nothing.
\end{itemize}


\subsection{Clauses}

\comp{
  \begin{align*}
    \gramdef{ClauseImplantation} = \: & \gramN{ClauseSees} \mid \\
                                      & \gram{ClauseImports} \mid \\
                                      & \gramN{ClausePromotes} \mid \\
                                      & \gramN{ClauseExtendsB0} \mid \\
                                      & \gramN{ClauseSets} \mid \\
                                      & \gramN{ClauseConcreteConstants} \mid \\
                                      & \gramN{ClauseProperties} \mid \\
                                      & \gram{ClauseValues} \mid \\
                                      & \gram{ClauseConcreteVariables} \mid \\
                                      & \gramN{ClauseInvariant} \mid \\
                                      & \gramN{ClauseAssertions} \mid \\
                                      & \gram{ClauseInitialisationB0} \mid \\
                                      & \gram{ClauseOperationsB0}
  \end{align*}
}{
  \begin{align*}
    \gramdef{ClauseImplantation'} = \: & \gramN{ClauseSees} \mid \\
                                       & \gram{ClauseImports'} \mid \\
                                       & \gramN{ClauseConcreteConstants} \mid \\
                                       & \gramN{ClauseProperties} \mid \\
                                       & \gram{ClauseValues'} \mid \\
                                       & \gram{ClauseConcreteVariables'} \mid \\
                                       & \gramN{ClauseInvariant} \mid \\
                                       & \gramN{ClauseAssertions} \mid \\
                                       & \gram{ClauseInitialisationB0'} \mid \\
                                       & \gram{ClauseOperationsB0'}
  \end{align*}
}


\comp{
\begin{align*}
  \gramdef{ClauseImports} = \: & \rtext{IMPORTS}   \left(
                                 \gram{IdentRen} \left(
                                 \gram{InstanciationB0}+^{\rtext{,}}
                                 \right)?
                                 \right)+^{\rtext{,}}
\end{align*}
}{
  \begin{align*}
    \gramdef{ClauseImports'} = \: & \rtext{IMPORTS}   \left(
                                   \gram{IdentRen} 
                                   \right)+^{\rtext{,}}
  \end{align*}
}


\comp{
\begin{align*}
  \gramdef{ClauseConcreteVariables} = \: & \rtext{CONCRETE\_VARIABLES}   \gram{IdentRen}*^{\rtext{,} }
\end{align*}
}{
  \begin{align*}
  \gramdef{ClauseConcreteVariables'} = \: & \rtext{CONCRETE\_VARIABLES}   \gram{Ident}*^{\rtext{,} }
  \end{align*}
}

\comp{
  \begin{align*}
    \gramdef{ClauseValues} = \: & \rtext{VALUES}   \gram{Valuation}+^{\rtext{;} }
  \end{align*}
}{
  \begin{align*}
    \gramdef{ClauseValues'} = \: & \rtext{VALUES}   \gram{Instruction}*^{\rtext{;} }
  \end{align*} 
}

\comp{
  \begin{align*}
    \gramdef{ClauseInitialisationB0} = \: & \rtext{INITIALISATION}   \gram{Instruction}*^{\rtext{;} }
  \end{align*}
}{
  \begin{align*}
    \gramdef{ClauseInitialisationB0'} = \: & \rtext{INITIALISATION}   \gram{Instruction'}*^{\rtext{;} }
  \end{align*} 
}


\comp{
  \begin{align*}
    \gramdef{ClauseOperationsB0} = \: & \rtext{OPERATIONS}   \gram{OpérationB0}*^{\rtext{;} }
  \end{align*}
}{
  \begin{align*}
    \gramdef{ClauseOperationsB0'} = \: & \rtext{OPERATIONS}   \gram{OpérationB0'}*^{\rtext{;} }
  \end{align*} 
}


\comp{
  \begin{align*}
    \gramdef{OpérationB0} = \: & \gram{EntêteOpération}   \: \rtext{=}   \: \gram{Instruction}+^{\rtext{;}}
  \end{align*}
}{
  \begin{align*}
    \gramdef{OpérationB0'} = \: & \gram{EntêteOpération'}   \: \rtext{=}   \: \gram{Instruction'}+^{\rtext{;}}
  \end{align*} 
}


\comp{
  \begin{align*}
    \gramdef{EntêteOpération} = \: & \left(\gram{Ident}^{+\rtext{,} }  \rtext{<--}\right)?
                                     \gram{IdentRen} \left(
                                     \rtext{(} \gram{Ident}+^{\rtext{,}} \rtext{)}
                                     \right)?
  \end{align*}
}{
  \begin{align*}
    \gramdef{EntêteOpération'} = \: & \left(\gram{Ident}^{+\rtext{,} }  \rtext{<--}\right)?
                                     \gram{Ident} \left(
                                     \rtext{(} \gram{Ident}+^{\rtext{,}} \rtext{)}
                                     \right)?
  \end{align*} 
}



\subsection{Instructions}

\comp{
  \begin{align*}
    \gramdef{Instruction} = \: & \gramN{BlockInstruction} \mid \\
                               & \gram{LocalVariableInstruction} \mid \\
                               & \gramN{IdentitySubstitution} \mid \\
                               & \gram{BecomesEqualInstruction} \mid \\
                               & \gramN{OperationCallInstruction} \mid \\
                               & \gram{ConditionalInstruction} \mid \\
                               & \gramN{CaseInstruction} \mid \\
                               & \gram{AssertionInstruction} \mid \\
                               & \gram{SequenceInstruction} \mid \\
                               & \gram{SubstitutionTantQue}
  \end{align*}
}{
  \begin{align*}
    \gramdef{Instruction'} = \: & \gram{LocalVariableInstruction'} \mid \\
                                & \gram{BecomesEqualInstruction'} \mid \\
                                & \gram{SubstitutionDevientEltDe'} \mid \\
                                & \gram{ConditionalInstruction'} \mid \\
                                & \gram{AssertionInstruction'} \\
                                & \gram{SequenceInstruction'} \mid \\
                                & \gram{SubstitutionTantQue'} \\
  \end{align*} 
}


\comp{
  \begin{align*}
    \gramdef{LocalVariableInstruction} = \: & \rtext{VAR}   \gram{Ident}^{+\rtext{,}}   \\
                                            & \rtext{IN}   \gram{Instruction}   \rtext{END}
  \end{align*}
}{
  \begin{align*}
    \gramdef{LocalVariableInstruction'} = \: & \rtext{VAR}   \gram{Ident}^{+\rtext{,}}   \\
                                             & \rtext{IN}   \gram{Instruction'}   \rtext{;}   \\
                                             & \gram{Instruction'}   \rtext{END}
  \end{align*}
}

It needs to have at least two nested instructions.


\comp{
  \begin{align*}
    \imfdef{\gramdef{BecomesEqualInstruction}} \\
    \hspace{0.4cm} = \: & \gram{IdentRen} \left( \rtext{(} \: \gram{Terme}\!+^{\rtext{,}} \: \rtext{)} \right)? \: \rtext{:=} \: \gram{Terme} \mid \\
                                           & \gram{IdentRen} \: \rtext{:=} \: \gram{ExprTableau} \mid \\
                                           & \gram{IdentRen} \left( \rtext{'} \: \gram{Ident} \right)\!+ \rtext{:=} \: \gram{Terme}
  \end{align*}
}{
  \begin{align*}
    \imfdef{\gramdef{BecomesEqualInstruction'}} \\
    \hspace{0.4cm} = \: & \gram{Ident'} \left( \rtext{(} \: \gram{Terme'}\!+^{\rtext{,}} \: \rtext{)} \right)? \: \rtext{:=} \: \gram{Terme'} \mid \\
                                           & \gram{Ident'} \: \rtext{:=} \: \gram{ExprTableau'} \mid \\
                                            & \gram{Ident'} \rtext{:=} \: \gram{Terme'}
  \end{align*}
}


\begin{align*}
  \gramdef{SubstitutionDevientEltDe'} = \: & \gram{Ident}   \rtext{::}   \gram{RecognizedType}
\end{align*}

This special substitution is technically not an instruction ({\ie} it is not B0-compliant). However, it will be considered as an instruction in the following sections. For its usage, see the input requirement number~\ref{varinbecomesin}.


\comp{
  \begin{align*}
    \gramdef{ConditionalInstruction} = \: & \rtext{IF}   \gram{Condition}   \\
                                          & \rtext{THEN}   \gram{Instruction}   \\
                                          & \left( \begin{array}{c}
                                              \rtext{ELSIF}   \gram{Condition}   \\
                                              \rtext{THEN}   \gram{Instruction} \\
                                            \end{array} \right)\!*^{ } \\
                                          & \left( \rtext{ELSE}   \gram{Instruction} \right) ?   \\
                                          & \rtext{END}
  \end{align*}
}{
  \begin{align*}
    \gramdef{ConditionalInstruction'} = \: & \rtext{IF}   \gram{Condition'}   \\
                                           & \rtext{THEN}   \gram{Instruction'}   \\
                                           & \left( \begin{array}{c}
                                               \rtext{ELSIF}   \gram{Condition'}   \\
                                               \rtext{THEN}   \gram{Instruction'}
                                             \end{array} \right)\!*^{ } \\
                                           & \left( \rtext{ELSE}   \gram{Instruction'} \right) ?   \\
                                           & \rtext{END}
  \end{align*}
}


\comp{
  \begin{align*}
    \gramdef{AssertionInstruction} = \: & \rtext{ASSERT}   \\
                                        & \gramN{Prédicat}   \\
                                        & \rtext{THEN}   \\
                                        & \gram{Instruction}   \\
                                        & \rtext{END}
  \end{align*}
}{
  \begin{align*}
    \gramdef{AssertionInstruction'} = \: & \rtext{ASSERT}   \\
                                         & \gramN{Prédicat}   \\
                                         & \rtext{THEN}   \\
                                         & \gram{Instruction'}   \\
                                         & \rtext{END}
  \end{align*}
}

The elements after the \texttt{INVARIANT} and \texttt{VARIANT} keyword concern the B~proof and are just ignored when it comes to the translation. So, you can just put anything around them.


\comp{
  \begin{align*}
    \gramdef{SequenceInstruction} = \: & \gram{Instruction}   \rtext{;}   \\
                                       & \gram{Instruction}
  \end{align*}
}{
  \begin{align*}
    \gramdef{SequenceInstruction'} = \: & \gram{Instruction'}   \rtext{;}   \\
                                        & \gram{Instruction'}
  \end{align*}
}


\comp{
  \begin{align*}
    \gramdef{SubstitutionTantQue} = \: & \rtext{WHILE} \gram{Condition} \rtext{DO} \\
                                       & \gram{Instruction} \\
                                       & \rtext{INVARIANT} \gramN{Prédicat} \\
                                       & \rtext{VARIANT} \gramN{Expression} \\
  \end{align*}
}{
  \begin{align*}
    \gramdef{SubstitutionTantQue'} = \: & \rtext{WHILE} \gram{Condition'} \rtext{DO} \\
                                       & \gram{Instruction'} \\
                                       & \rtext{INVARIANT} \gramN{Prédicat} \\
                                       & \rtext{VARIANT} \gramN{Expression} \\
  \end{align*}
}


\subsection{Condition}

\comp{
  \begin{align*}
    \gramdef{Condition} = \: & \gram{TermeSimple} \: \rtext{=} \: \gram{TermeSimple} \mid \\
                             & \gram{TermeSimple} \: \rtext{/=} \: \gram{TermeSimple} \mid \\
                             & \gram{TermeSimple} \: \rtext{<} \: \gram{TermeSimple} \mid \\
                             & \gram{TermeSimple} \: \rtext{>} \: \gram{TermeSimple} \mid \\
                             & \gram{TermeSimple} \: \rtext{<=} \: \gram{TermeSimple} \mid \\
                             & \gram{TermeSimple} \: \rtext{>=} \: \gram{TermeSimple} \mid \\
                             & \gram{Condition} \: \rtext{\&} \: \gram{Condition} \mid \\
                             & \gram{Condition} \: \rtext{or} \: \gram{Condition} \mid \\
                             & \rtext{not}   \rtext{(} \gram{Condition} \rtext{)} \mid \\
                             & \rtext{(} \gram{Condition} \rtext{)}
  \end{align*}
}{
  \begin{align*}
    \gramdef{Condition'} = \: & \gram{TermeSimple'} \: \rtext{=} \: \gram{TermeSimple'} \mid \\
                              & \gram{TermeSimple'} \: \rtext{/=} \: \gram{TermeSimple'} \mid \\
                              & \gram{TermeSimple'} \: \rtext{<} \: \gram{TermeSimple'} \mid \\
                              & \gram{TermeSimple'} \: \rtext{>} \: \gram{TermeSimple'} \mid \\
                              & \gram{TermeSimple'} \: \rtext{<=} \: \gram{TermeSimple'} \mid \\
                              & \gram{TermeSimple'} \: \rtext{>=} \: \gram{TermeSimple'} \\
                              & \gram{Condition'} \: \rtext{\&} \: \gram{Condition'} \mid \\
                              & \gram{Condition'} \: \rtext{or} \: \gram{Condition'} \mid \\
                              & \rtext{not}   \rtext{(} \gram{Condition'} \rtext{)} \mid \\
                              & \rtext{(} \gram{Condition'} \rtext{)}
  \end{align*}
}


\subsection{Expressions}

\comp{
  \begin{align*}
    \gramdef{ExprTableau} = \: & \gram{Ident} \mid \\
                               & \rtext{\{} \left( \gram{TermeSimple}^{+\rtext{|->}} \rtext{|->} \gram{Terme} \right)^{+\rtext{,}} \rtext{\}} \mid \\
                               & \gramN{EnsembleSimple}^{+\rtext{*}} \rtext{*\{} \gram{Terme} \rtext{\}}
  \end{align*}
}{
  \begin{align*}
    \gramdef{ExprTableau'} = \: & \gram{Ident} \mid \\
                               & \rtext{\{} \left( \gram{EntierLit'} \rtext{|->} \left( \gram{Terme} \mid \gram{ExprTableau'} \right) \right)^{+\rtext{,}} \rtext{\}} \\
  \end{align*}
}


\comp{
  \begin{align*}
    \gramdef{TermeSimple} = \: & \gram{IdentRen} \mid \\
                               & \gram{EntierLit} \mid \\
                               & \gram{BooléenLit} \mid \\
                               & \gram{IdentRen} \left( \rtext{'} \: \gram{Ident} \right)+
  \end{align*}
}{
    \begin{align*}
      \gramdef{TermeSimple'} = \: & \gram{EntierLit'} \mid \\
                                  & \gram{BooléenLit} \mid \\
                                  & \gram{Ident}
    \end{align*}
}


\comp{
  \begin{align*}
    \gramdef{IdentRen} = \: & \gram{Ident}+^{\rtext{,}}
  \end{align*}
}{
  \begin{align*}
    \gramdef{IdentRen'} = \: & \gram{Ident}+^{\rtext{,}}
    \end{align*}
  }

  A renamed indentifier.



  \begin{align*}
  \gramdef{Ident} = \: & \left( [\rtext{a}-\rtext{z}] \mid [\rtext{A}-\rtext{Z}] \right) \mid \left( [\rtext{a}-\rtext{z}] \mid [\rtext{A} - \rtext{Z}] \mid [\rtext{0} - \rtext{9}] \mid \rtext{\_} \right)*
\end{align*}



\begin{align*}
  \gramdef{BooléenLit} = \: & \rtext{FALSE} \mid \rtext{TRUE}
\end{align*}


\comp{
  \begin{align*}
    \gramdef{Terme} = \: & \gram{TermeSimple} \mid \\
                         & \gram{ExpressionArithmétique} \mid \\
                         & \gramN{TermeRecord} \mid \\
                         & \gramN{TermeRecord} \left(\rtext{'} \: \gram{Ident} \right)+
  \end{align*}
}{
  \begin{align*}
    \gramdef{Terme'} = \: & \gram{TermeSimple'} \mid \\
                          & \gram{ExpressionArithmétique'}
  \end{align*}
}


\comp{
  \begin{align*}
    \gramdef{ExpressionArithmétique} = \: & \gram{EntierLit} \mid \\
                                          & \gram{IdentRen} \mid \\
                                          & \gram{IdentRen} \rtext{(} \gram{Terme}+^{\rtext{,}} \rtext{)}+ \mid \\
                                          & \gram{IdentRen} \left( \rtext{'} \gram{Ident} \right) \mid \\
                                          & \left( \begin{array}{c}
                                              \gram{ExpressionArithmétique} \\
                                              \left[\rtext{+}\rtext{-}\rtext{*}\rtext{/}\left(  \rtext{mod}   \right)\rtext{**}\right] \\
                                              \gram{ExpressionArithmétique}
                                              \end{array} \right) \mid \\
                                          & \rtext{-} \gram{ExpressionArithmétique} \mid \\
                                          &  \rtext{succ(} \gram{ExpressionArithmétique} \rtext{)} \mid \\
                                          & \rtext{pred(} \gram{ExpressionArithmétique} \rtext{)} \mid \\
                                          & \rtext{(} \gram{ExpressionArithmétique} \rtext{)} \\
  \end{align*}
}{
  \begin{align*}
    \gramdef{ExpressionArithmétique'} = \: & \gram{EntierLit'} \mid \\
                                           & \gram{Ident} \mid \\
                                              & \left( \begin{array}{c}
                                              \gram{ExpressionArithmétique} \\
                                              \left[\rtext{+}\rtext{-}\rtext{*}\rtext{/}\left(  \rtext{mod}   \right)\rtext{**}\right] \\
                                              \gram{ExpressionArithmétique}
                                              \end{array} \right) \\
  \end{align*}
}


\comp{
  \begin{align*}
    \gramdef{EntierLit} = \: & \gram{EntierLittéral} \mid \\
                             & \rtext{MAXINT} \mid \\
                             & \rtext{MININT}
  \end{align*}
}{
  \begin{align*}
    \gramdef{EntierLit'} = \: & \gram{EntierLittéral'}
  \end{align*}
}


\comp{
  \begin{align*}
    \gramdef{EntierLittéral} = \: & \rtext{-}? \left[0-9\right]\!+
  \end{align*}

  An \gram{EntierLittéral} (a literal of integer) has to be $\geq \rtext{MININT}$ and $\leq \rtext{MAXINT}$.
}{
  \begin{align*}
    \gramdef{EntierLittéral'} = \: & \rtext{-}?\left[0-9\right]\!+
  \end{align*}
}


\begin{align*}
  \gramdef{Digit} = \: & \left[0-9\right]\!+
\end{align*}


\subsection{Recognized types}

\begin{align*}
  \gramdef{RecognizedType} = \: & \rtext{rust\_i32} \mid \rtext{rust\_i16} \mid \rtext{rust\_i8} \mid \rtext{rust\_bool} \mid \\
                                & \rtext{0..} \gram{Digit} \rtext{--> (}
                                  \gram{RecognizedType}
                                  \rtext{)}
\end{align*}

Note that:
\begin{itemize}
\item The types you may find strange (\rtext{rust\_i32}, etc.) are Rust types defined in B; they are defined in a file your components have to \texttt{SEE}. More information on the Rust types can be found \hyperref[appendixTypes]{in the appendix}.
\item So, the only relations allowed in "BRust" are total function from an integer interval beginning with 0.
\item If the right member is a simple recognized type, a version without the parentheses is also parsed.
\end{itemize}

\section{Translation scheme}
\label{TranslationScheme}

The role of this part is to specify the translation scheme of {\br}.


\subsection{{\br} inner workings}

Firstly, let us give some information. {\br} consists of a main source file, \texttt{b2rust.cpp}, which:

\begin{enumerate}
\item Creates an \texttt{Input} object from the command lines arguments. This is done because:
  \begin{enumerate}
  \item When a command line argument is needed, it shouldn't be the role of every function to parse the \texttt{argv} argument. Instead, it is better to just query an attribute of an "Input" object;
  \item Not all functions should be able to access the command line arguments;
  \item The despicable \texttt{const char*} arguments have to be converted into nice \texttt{string} elements (maybe see \hyperref[SectionCoding]{the development conventions section}).
  \end{enumerate}

  If the \texttt{Input} succeeds, it gives the programmer a \texttt{Module} (an object which consist of two \texttt{XMLElement*} pointing to the BXML implementation and the BXML abstract file) for the entry module and a \texttt{map} of \texttt{Module}s for every imported module.
\item \label{stepParser} Translate the entry module into a \texttt{Parser} (an object which consist of a C++ representation of the machine and a C++ representation of the implementation) and the \texttt{map} of \texttt{Module}s into a \texttt{map} of \texttt{Parser}s. This is the \textit{parsing}. It allows us to reduce the request to the XML library and not having to deal with the XML syntax which can be deconcerting. The parsing take care of taking all relevant information from the BXML files and representing them into a C++ object. The translation must be straightforward and no structure optimization must be made (however, some tiny assumptions are made on the BXML input given they respect the B~language). This allows us to write scalable parsing functions.
\item \label{stepChecker} Calls the \texttt{Checker}. Its theoretical role is to prevent usage of {\br} for modules which do not follow the requirements of section~\ref{moduleSubset}, however, it does not completely works.
\item \label{stepConverter} Translate the entry module parser into a \texttt{RustModule} (an object which represent a Rust module) and the \texttt{map} of \texttt{Parser}s into a \texttt{map} of \texttt{RustModule}s. This is the \textit{conversion}. This is where the serious job is done; a \texttt{RustModule} needs to be architecturally extremely close to a Rust code.
\item \label{stepPrinter} Prints every \texttt{RustModule}. The structure of a \texttt{RustModule} should be defined so that its printing is extremely straightforward. It should only consist of going over all attributes and subobjects and using a print function on them. The only optimization allowed it that an attribute may be printed more than once, but even that should be avoided if this leads to a still reasonable structure. Every \texttt{RustModule} is printed into a different file whose name is the one of the module, plus "\texttt{.rs}"; so, \textbf{a B~module is bijectively associated by exactly one produced code file}.
\end{enumerate}


This document shan't specify precisely the translation scheme of all these steps; luckily (and purposely), the step~\ref{stepParser} is straightforward enough we can omit its specification\footnote{Because the C++ representation of the BXML file is extremely straightforward, as explained above; however, you need to know some assumptions are made on the BXML input file structure, so, the C++ structure of a parsed object doesn’t \textit{fully} match the BXML specification. I think the BXML contains imprecisions and there’s \hyperref[bxmlimprecisions]{an appendix section dedicated to this}.}. The step~\ref{stepChecker} does not infer with the translation (it just reads data and, maybe, stops the translation).
The step~\ref{stepPrinter} should be specified, however, it deals with "output files" and we need to think of a way to mathematically represent this.

So, to sum it up, we need to specify precisely the \texttt{RustModule} object and the steps done to convert a \texttt{Parser} to a \texttt{RustModule} and a \texttt{RustModule} to a file. We need to find a way to represent C++ objects and a file stream.
  

\subsection{Mathematical definitions}

To represent mathematically the translation operated by {\br}, we represent the BXML input files, the C++ converted object defined by the \textit{converter} and the code output by mathematical entities we call \textit{structures}. Let us give some definitions.

\begin{itemize}
\item $\bool = \{\top, \bot\}$.
\item $\str$ is the set of all alphanumeric strings, plus the underscore and \rtext{\CR}, the carriage return character which represents a new line. The elements of $\str$ are typeset using a box with a shadow or with a rounded box, without incidence of their definition ($\rtext{\_grasshopper12} = \ulobj{\_grasshopper12} \in \str$, for example). The choice of the notation depends on the willing of the writer and on the practical object we represent by a mathematical string; if it is a computational string, we will likely use the box with a shadow; if it is a file or a C++ \texttt{enum}, we will likely use a rounded box. $\rtext{}$ (or $\ulobj{}$) is an empty string.
\item If $a_1 \in A_1, \cdots, a_n \in A_n$, $\{a_1, \cdots, a_n\}$ is just a mathematical set, so, it has no order ($\{1, 2\} = \{2, 1\}$) and the cardinal of a set is its number of different elements: $\lvert\{1, 2, 1\}\rvert = 2$. (The elements of a set can have different properties, for example, $\left\{3, \{\}\right\} \in \mathbb{P}(\mathbb{Z} \cup \mathbb{P}(\tint))$ is a valid set.)

  We say a set can be recursively defined, for example, if we define $S = \mathbb{P}(\tint \cup S)$, we have $\left\{1, 3, \left\{2, \{1, 3\}\right\}\right\} \in S$.
  
\item $(a_1, \cdots, a_n)$ is called a tuple. Contrarily to sets, a tuple is ordered ($(1, 2) \neq (2, 1)$). There's only one way to represent a tuple; its number of elements (which can be redundant) is always defined: $\lvert(1, 2, 1)\rvert = 3$.

  Note we also define the $\in$ and $\notin$ operators on a tuple,
  % ; if $n > 25$ and $a_1, \cdots, a_n$ are $n$ structures, $a_9 \in (a_1, \cdots, a_n)$. $\forall$ and $\exists$ quantifier are also defined to have a meaning in tuples,
  but their meaning is counter-intuitive; actually, if $a \in A$ and $b \in B$, we say that $(a, b)$ is mathematically represented as $\{\{\{a\}, 1\}, \{\{b\}, 2\}\}$. So, it is the reason why $a \in (a, b)$ is false, but $(\{\{a\}, 1\} \in (a, b)$ is true. This definition ensures that a tuple is ordered \textit{and} can be defined from equals elements. We can however write $a \inplus (a, b)$: if $t$ is a tuple and $a$ and element,
  \[
    a \inplus t \iff \exists n \in \tnat, \{\{a\}, n\} \in t
  \]

  Note that if $t$ and $u$ are tuples, $t \cup u$ is not a tuple, but $a \inplus t \cup u$ makes sense like we wish it would.

  The same remark goes for the $\exists$ and $\forall$ quantifiers: so, $\forall k \in (1, 2, 1)$ iterates on three \textit{different} elements, but $\forall k \inplus (1, 2, 1)$ only iterates on two.

  % The $\toelement{\cdot}$ operator can be useful; if $a \in \mathcal{S}$ and $i \in \tnat$, $\toelement{(a, i)} = i$.

  % In this document, a tuple can also be typeset $a_1 \nxt \cdots \nxt a_n$, like in the B~syntax. We define the $\nxt$ operator with an higher precedence as the $,$ one, so, the structure $\{a_1, a_2 \nxt a_3, a_4\}$ is the structure $\{a_1, (a_2, a_3), a_4\}$. Caution, the $\nxt$ operator is not associative\ec for example, $1 \nxt (2 \nxt 3) \neq (1 \nxt 2) \nxt 3$.

  Finally, as a tuple is ordered, we can refer to its elements using an \textit{index} (note that a tuple is ordered from 1). So, if $n \geq 25$ and $t = (a_7, a_9, a_1)$, $t_3 = a_1$ and $t_1 = a_7$.


\item \textit{Structures} are mathematical entities which can be used to represent documents, code, or C++ objects. $\mathcal{S}$ is the set of all structures. In a nutshell, a structure is a tuple indexed by strings (we say that the \textit{keys} are strings), so, for example, $s = \{\{\{a_3\}, \rtext{cat}\}, \{\{a_9\}, \rtext{dog}\}\}$ is a structure. This allows us to write $s\sref{cat} = a_3$ (note the key is typeset in sans serif and not anymore with a box). In a structure, all the keys are pairwise distinct. Like the tuples, we can write $a_9 \inplus s$ and we call the \textit{data} of a structure $s$ the set $\{d \mid d \inplus s\}$ (we can say that $a_9$ is a \textit{data} of $s$, for instance). Contrarily to tuples, \textbf{a structure is not ordered.} This is because we do not define an order in $\str$, so, we cannot know if $\rtext{cat} < \rtext{dog}$, for example.

  A structure can be represented with brackets, with the syntax which follows. If $s_1, \cdots, s_n \in \str$, we can write
  \[
    s = \left[
      \begin{array}{ll}
        \fotm{s_1}{a_1}, \\
        \cdots, \\
        \fotm{s_n}{a_n}
      \end{array}
    \right] = \{\{\{a_1\}, s_1\}, \cdots, \{\{a_n\}, s_n\}\}
  \]

  We say this syntax uses \textit{fields}: for example, $\begin{array}{ll}\fotm{s_8}{a_8}\end{array}$ is a field. (There’s a chariot return between each field in this example, but it is not mandatory.)

  As a structure is not ordered, we could also write
  \[
    s = \left[
      \begin{array}{ll}
        \fotm{s_n}{a_n}, \\
        \cdots, \\
        \fotm{s_1}{a_1}
      \end{array}
    \right]
  \]

  However, if a structure has only one field, the key can of course be implied:
  \[
    s = \Struct{\fot{animal}{\rtext{cat}}} = \Struct{\rtext{cat}}
  \]

    In this example, the data $\rtext{cat}$ can be represented by $s\sref{animal}$, but let us admit we can also write $\srefq{s}$. This is because the name of the key is not relevant when we deal with struct with an unique field.
  
\item Now, it would be fine if we could define \textit{sets} of structures. A set of structures is often typeset under the shape $\mathcal{S}_\text{\cdot}$ or under the shape $\st{Type}$ (which defines a link in the numeric version of this document) and its definition uses doubled brackets and \textit{fields definition} which use the $:\in$ operator:

  \[
  \mathcal{S}_s = \StructS{
    \begin{array}{ll}
      \fdefm{s_1}{A_1}, \\
      \cdots, \\
      \fdefm{s_n}{A_n}
    \end{array}
  }
  = \left\{\left\{\left\{\left\{\alpha_1\right\}, s_1\right\}, \cdots, \left\{\{\alpha_n\}, s_n\right\}\right\} \middle| \alpha_1 \in A_1, \cdots, \alpha_n \in A_n\right\}
  \]
  Remark: the sets used in definition of sets of structures can be everything (including other sets of structures). So, if we use Cartesian products, we can refer to elements easily: for example, if $k, k' \in \str$,
  \[
    \mathcal{S}_s = \StructS{
        \fdefm{k}{A_1^n}, \\
        \fdefm{k'}{A_2}
    }
  \]
  and $s \in \mathcal{S}_s$, we could write $s.k'$ as well as $s.k_8$ (or even $s.k$). (As $s.k \in A_1^n$, it is a tuple, so, its elements are ordered.)
  
  During a set of structure definition, if a key is not specified, consider the key is anything different that the ones already in use (which is possible as a structure has always a countable number of fields).
  \[
    \left[
      \begin{array}{ll}
        \fot{cat}{13}, \\
        \fot{dog}{\rtext{parrot}}, \\
        \imfdef{\rtext{grasshopper}}
      \end{array}
    \right]
  \]

\item If $A$ is a set, $A^\infty = \displaystyle\bigcup_{k \in \tnat}A^k$. Note that if $a \in A^\infty$ and $\lvert a \rvert = 9$, for instance, $a \in A^9$ but $a \notin A^8$ and $a \notin A^{10}$.
  
\item A structure can be quite useful to represent mathematically some concrete data (as C++ objects which have most of the time attributes which can be referred thanks to structures), but its definition can be quite troublesome when we want to represent documents or character strings which match a specific grammar. This is because the data of a structure are not \textit{ordered}, so, there is not an unique way to represent it, and there’s not an unique way to print a structure, for instance. This is the reason why we define now \textit{ordered structures}. Mathematically, an order structure is an element of $\mathcal{S} \times \mathbb{P}\left(\str^2\right)$. An element of $\str^2$ defines an order between two keys. So, an element of $\mathbb{P}\left(\str^2\right)$ is just a set of key orders. An unordered structure like the ones we used previously can be seen as an ordered structure which has no key order defined, {\ie} an element of $\mathcal{S} \times \{\} \subset \mathcal{S} \times \mathbb{P}\left(\str^2\right)$. Here is an example of an ordered structure which is not an unordered structure:

  \smallskip
  \begin{adjustbox}{center}
    \(
    \left(
      \begin{array}{c}
        \left\{
        \left\{\{12\}, \rtext{cat}\right\},
        \left\{\{24\}, \rtext{dog}\right\},
        \left\{\{23\}, \rtext{parrot}\right\},
        \left\{\{127\}, \rtext{grasshopper}\right\}
        \right\}, \\
        \left\{
        \left(\rtext{grasshopper}, \rtext{cat}\right),
        \left(\rtext{grasshopper}, \rtext{dog}\right)
        \right\}
      \end{array}
    \right)
    \)
  \end{adjustbox}
  \smallskip

  In this example, the data $127$ (associated to the key $\rtext{grasshopper}$) is defined as being \textit{before} the data $12$ or $24$.

  The syntax used later is also used for ordered structures, but it can make use another operator: $\nxt$, which can replace the coma. It means the ordered structure specifies an order between the two keys. If we take the last example and replace $\left(\rtext{grasshopper}, \rtext{dog}\right)$ with $\left(\rtext{cat}, \rtext{dog}\right)$, the ordered structure can now be represented like this:
  \[
    \left[
      \begin{array}{ll}
        \fot{grasshopper}{127} \nxt \\
        \fot{cat}{12} \nxt \\
        \fot{dog}{24}, \\
        \fot{parrot}{23} \\
      \end{array}
    \right]
  \]

  The syntax used for structures set is also expanded the same way to define ordered structures sets:
  
  \smallskip
  \begin{adjustbox}{center}
    \(
    \StructS{
        \fdefm{s_2}{A_2}, \\
        \fdefm{s_1}{A_1} \nxt \\
        \fdefm{s_3}{A_3},
    } = \left\{\left(
        \begin{array}{c}
          \left\{
          \left\{\left\{\alpha_2\right\}, s_2\right\},
          \left\{\left\{\alpha_1\right\}, s_1\right\},
          \left\{\left\{\alpha_3\right\}, s_3\right\}
          \right\}, \\
          \left\{
          (\alpha_1, \alpha_3)
          \right\}
        \end{array}
      \right) \middle| \alpha_1 \in A_1, \alpha_2 \in A_2, \alpha_3 \in A_3
    \right\}
    \)
  \end{adjustbox}
  \smallskip

  You might have noticed that the definition of an ordered structure "breaks" the $\lvert \cdot \rvert$ operator. So, if $s$ is an ordered structure, we define $\lVert s \rVert = \lvert s_1 \rvert$ which matches with what we want.

  Also, if $s$ is an ordered structure, its first element, $s_1$ is an unordered structure which has exactly the same fields. The notation $\rus{s}$, more explicit than $s_1$, can be used. 

\item An ordered structure is told \textit{totally ordered} if the orders definition "cover each key and forms a chain", or if it can be represented with the bracket syntax without commas but arrows. (This specific structure can be used to represent a document or a character string, for instance.) We define a specific syntax to allow the user not to use arrows everywhere:
    \[
    \StructS{
        \fdefm{s_1}{A_1} \nxt \\
        \fdefm{s_2}{A_2} \nxt \\
        \fdefm{s_3}{A_3}
    } = \left\Downarrow
      \begin{array}{ll}
        \fdefm{s_1}{A_1}, \\
        \fdefm{s_2}{A_2}, \\
        \fdefm{s_3}{A_3}
      \end{array}
      \right\Downarrow
    \]

  \[
    \left[
      \begin{array}{ll}
        \fotm{s_1}{a_1} \nxt \\
        \fotm{s_2}{a_2} \nxt \\
        \fotm{s_3}{a_3}
      \end{array}
    \right] = \left\downarrow
      \begin{array}{ll}
        \fotm{s_1}{a_1}, \\
        \fotm{s_2}{a_2}, \\
        \fotm{s_3}{a_3}
      \end{array}
    \right\downarrow = \left\downarrow a_1, a_2, a_3 \right\downarrow
  \] 
  
    We define by $\tos$ the set of totally ordered structures.
\end{itemize}

Now that everything has been defined, let us define the translation scheme. {\br} takes as input BXML files we represent as ordered structures of an ordered structure set, $\mathcal{S}_\text{BXML}$. It translates them into C++ objects of type \texttt{RustModule} we represent as elements of $\mathcal{S}_\text{converted}$. For each \texttt{RustModule}, it then prints a code which is represented as an element of $\mathcal{S}_\text{Rust}$.

\subsection{$\mathcal{S}_\text{BXML}$}

\[
  \mathcal{S}_\text{BXML} = \left\Downarrow
  \begin{array}{ll}
    \fdef{Abstraction}{\str}, \\
    \fdef{Imports}{\st{instance\_list\_type}}, \\
    \fdef{Values}{\st{Valuation}^\infty}, \\
    \fdef{Concrete\_Constants}{\st{Id}^\infty}, \\
    \fdef{Concrete\_Variables}{\st{Id}^\infty}, \\
    \fdef{Properties}{\st{pred\_group}}, \\
    \fdef{Invariant}{\st{pred\_group}}, \\
    \fdef{Initialisation}{\st{Sub}}, \\
    \fdef{Operations}{\st{Operation}^\infty} \\
  \end{array}
  \right\Downarrow
\]


\std{instance\_list\_type}{
  \StructS{
      \fdef{Referenced\_Machine}{\st{Referenced\_Machine}^\infty}
  }
}


\std{Referenced\_Machine}{
  \OStructS{
    \fdef{Name}{\str}, \\
    \fdef{Instance}{\str} \\
  }
}


\std{Valuation}{
  \StructS{
      \fdef{ident}{\str}, \\
      \fdef{Exp}{\st{Exp}^\infty}
  }
}

\std{Exp}{
  \begin{array}{llllllll}
    \st{Unary\_Exp}  & \cup
    \st{Binary\_Exp}  & \cup
    \st{Ternary\_Exp}  & \cup
    \st{Nary\_Exp}  & \cup \\
    \st{Boolean\_Literal}  & \cup
    \st{Boolean\_Exp}  & \cup
    \st{EmptySet}  & \cup
    \st{EmptySeq}  & \cup \\
    \st{Id}  & \cup
    \st{Integer\_Literal}  & \cup
    \st{Quantified\_Exp}  & \cup
    \st{Quantified\_Set}  & \cup \\
    \st{STRING\_Literal}  & \cup
    \st{Struct}  & \cup
    \st{Record}  & \cup
    \st{Real\_Literal}  & \cup \\
    \st{Record\_Field\_Access} 
  \end{array}
}

\std{Binary\_Exp}{
  \OStructS{
    \fdef{Exp}{\st{Exp}^2}, \\
    \fdef{op}{\st{binary\_exp\_op}}
  }
}


\std{binary\_exp\_op}{
  \left\{
  \begin{array}{llllllllllll llllllllllll}
    \rtext{,}, &
    \rtext{*}, &
    \rtext{*i}, &
    \rtext{*r}, &
    \rtext{*f}, &
    \rtext{*s}, &
    \rtext{**}, &
    \rtext{**i}, &
    \rtext{**r}, &
    \rtext{+}, &
    \rtext{+i}, &
    \rtext{+r}, & \\
    \rtext{+f}, &
    \rtext{+->}, &
    \rtext{+->>}, &
    \rtext{-}, &
    \rtext{-i}, &
    \rtext{-r}, &
    \rtext{-f}, &
    \rtext{-s}, &
    \rtext{-->}, &
    \rtext{-->>}, &
    \rtext{->}, &
    \rtext{..}, & \\
    \rtext{/}, &
    \rtext{/i}, &
    \rtext{/r}, &
    \rtext{/f}, &
    \rtext{/\textbackslash}, &
    \rtext{/|\textbackslash}, &
    \rtext{;}, &
    \rtext{<+}, &
    \rtext{<->}, &
    \rtext{<-}, &
    \rtext{<<|}, &
    \rtext{<|}, & \\
    \rtext{>+>}, &
    \rtext{>->}, &
    \rtext{>+>>}, &
    \rtext{>->>}, &
    \rtext{><}, &
    \rtext{||}, &
    \rtext{\textbackslash/}, &
    \rtext{\textbackslash|/}, &
    \rtext{\textasciicircum}, &
    \rtext{mod}, &
    \rtext{|->}, &
    \rtext{|>}, & \\
    \rtext{|>>}, &
    \rtext{[}, &
    \rtext{(}, &
    \rtext{<'}, &
    \rtext{prj1}, &
    \rtext{prj2}, &
    \rtext{iterate}, &
    \rtext{const}, &
    \rtext{rank}, &
    \rtext{father}, &
    \rtext{subtree}, &
    \rtext{arity} \: \! &
  \end{array}
  \right\}
}


\std{Boolean\_Literal}{
  \StructS{
    \fdef{value}{\bool}
  }
}


\std{Id}{
  \StructS{
    \fdef{value}{\str}
  }
}


\std{Integer\_Literal}{
  \StructS{
    \fdef{value}{\tint}
}  
}


\std{Nary\_Exp}{
  \OStructS{
    \fdef{exp}{\st{Exp}^\infty}, \\
    \fdef{op}{\st{nary\_exp\_op}}
  }
}


\std{nary\_exp\_op}{
  \rtext{[} \cup
  \rtext{\{}
}


\std{pred\_group}{
  \st{Binary\_Pred} \cup
  \st{Exp\_Comparison} \cup
  \st{Quantified\_Pred} \cup
  \st{Unary\_Pred} \cup
  \st{Nary\_Pred}
}


\std{Unary\_Pred}{
  \StructS{
    \fdef{pred\_group}{\st{pred\_group}}, \\
    \fdef{op}{\st{unary\_pred\_op}}
  }
}


\std{unary\_pred\_op}{
  \{\rtext{not}\}
}


\std{Nary\_Pred}{
  \StructS{
    \fdef{pred\_group}{\st{pred\_group}^\infty}, \\
    \fdef{op}{\st{nary\_pred\_op}}
  }
}


\std{nary\_pred\_op}{
  \left\{
    \rtext{\&},
    \rtext{or}
  \right\}
}


\std{Exp\_Comparison}{
  \OStructS{
    \fdef{Exp}{\st{Exp}^2}, \\
    \fdef{op}{\st{comparison\_op}}
  }
}


\std{comparison\_op}{
  \left\{
  \begin{array}{llllll llllll llllll llllll}
    \rtext{:}, &
    \rtext{/:}, &
    \rtext{<:}, &
    \rtext{/<:}, &
    \rtext{<<:}, &
    \rtext{/<<:}, &
    \rtext{=}, &
    \rtext{/=}, &
    \rtext{>=}, &
    \rtext{<}, &
    \rtext{<=}, &
    \rtext{>=i}, & \\
    \rtext{>i}, &
    \rtext{<i}, &
    \rtext{<=i}
  \end{array}
  \right\}
}


\std{Sub}{
  \begin{array}{llllll}
    \st{Bloc\_Sub} & \cup
    \ulobj{Skip} & \cup
    \st{Assert\_Sub} & \cup \\
    \st{If\_Sub} & \cup
    \st{Becomes\_Such\_That} & \cup
    \st{Assignement\_Sub} & \cup \\
    \st{Select} & \cup
    \st{Case\_Sub} & \cup
    \st{ANY\_Sub} & \cup \\
    \st{LET\_Sub} & \cup
    \st{VAR\_IN} & \cup
    \st{Nary\_Sub} & \cup \\
    \st{Operation\_Call} & \cup
    \st{Becomes\_In} & \cup
    \st{While} & \cup \\
    \st{Witness}
  \end{array}
}


\std{Assert\_Sub}{
  \OStructS{
    \fdef{Guard}{\st{predicate\_type}}, \\
    \fdef{Body}{\st{substitution\_type}}
  }
}

\std{Nary\_Sub}{
  \StructS{
    \fdef{Sub}{\st{Sub}^\infty}, \\
    \fdef{op}{\st{nary\_sub\_op}}
  }
}


For this one, \texttt{outputParameters} are supposed to be \st{Id}s and not \st{Exp}s (see section~\ref{bxmlimprecisions}).

\std{Operation\_Call}{
  \StructS{
    \fdef{name}{\StructS{
        \fdef{id}{\StructS{
            \fdef{value}{\str}, \\
            \fdef{instance}{\str}, \\
            \fdef{component}{\str} \\
          }}
      }}, \\
    \fdef{inputParameters}{\StructS{
          \fdef{exp}{\st{Exp}^\infty}
        }}, \\
    \fdef{outputParameters}{\StructS{
          \fdef{id}{\st{Id}^\infty}
        }
      } \\
  }
}


\std{nary\_sub\_op}{
  \left\{
    \rtext{||},
    \rtext{;},
    \rtext{CHOICE}
  \right\}
}

\std{If\_Sub}{
  \StructS{
    \fdef{Condition}{\st{predicate\_type}} \nxt \\
    \fdef{Then}{\st{substitution\_type}} \nxt \\
    \fdef{Else}{\st{substitution\_type}}, \\
    \fdef{elseif}{\str}
  }
}


\std{predicate\_type}{\st{pred\_group}}

\std{substitution\_type}{\st{Sub}}


\std{Assignement\_Sub}{
  \OStructS{
      \fdef{Variables}{\st{Exp}^\infty}, \\
      \fdef{Values}{\st{Exp}^\infty}
}  
}


\std{Operation}{
  \OStructS{
    \fdef{OutputParameters}{\st{Id}^\infty}, \\
    \fdef{InputParameters}{\st{Id}^\infty}, \\
    \fdef{Precondition}{\st{pred\_group}}, \\
    \fdef{Body}{\st{Sub}}, \\
    \fdef{name}{\str}
  }
}


\std{VAR\_IN}{
  \OStructS{
    \fdef{Variables}{\st{variables\_type}}, \\
    \fdef{Body}{\st{substitution\_type}}
  }
}

\std{While}{
  \OStructS{
    \fdef{condition}{\st{predicate\_type}}, \\
    \fdef{body}{\st{substitution\_type}}, \\
    \fdef{invariant}{\st{predicate\_type}}, \\
    \fdef{variant}{\st{expression\_type}}, \\
  }
}

\std{expression\_type}{
  \Struct{
    \fdef{exp}{\st{Exp}}
  }
}

\std{variables\_type}{
  \StructS{
    \fdef{\_Id}{\st{Id}^\infty}
  }
}


\std{Becomes\_In}{
  \OStructS{
    \fdef{Variables}{\st{variables\_type}}, \\
    \fdef{Value}{\st{expression\_type}}
  }
}


\std{expression\_type}{
  \StructS{
    \fdef{\_exp}{\st{Exp}}
  }
}



\subsection{$\mathcal{S}_\text{converted}$}

\[
  \mathcal{S}_{\text{converted}} = \StructS{
    \fdef{mods}{\str^\infty}, \\
    \fdef{uses}{\str^\infty}, \\
    \fdef{name}{\str}, \\
    \fdef{instances}{\left(\str \times \str\right)^\infty}, \\
    \fdef{variables}{\mathbb{P}(\str \times \st{Type})}, \\
    \fdef{instances\_init}{\str^\infty}, \\
    \fdef{values}{\st{RustInstruction}^\infty}, \\
    \fdef{initialisations}{\st{RustInstruction}^\infty}, \\
    \fdef{functions}{\st{Function}^\infty}
  }
\]


\std{Type}{\left\{
    \ulobj{i32\_t}, \ulobj{i16\_t}, \ulobj{i8\_t}, \ulobj{bool\_t}
  \right\} \cup \st{tabular}
}


\std{tabular}{
  \StructS{
    \fdef{size}{\mathbb{Z}^*}, \\
    \fdef{elementsType}{\st{Type}}, \\
  }
}

Represents a tabular type.


\std{RustInstruction}{\st{RustAssignement} \cup \st{RustIf} \cup \st{Block} \cup \st{Declaration} \cup \st{FunctionCall} \cup \st{RustWhile}}

\std{RustWhile}{
  \StructS{
    \fdef{condition}{\st{RustPredicate}}, \\
    \fdef{instructions}{\st{RustInstruction}^\infty}
  }
}

\std{FunctionCall}{
  \StructS{
    \fdef{moduleName}{\str}, \\
    \fdef{functionName}{\str}, \\
    \fdef{inputParameters}{\st{RustExpression}^\infty}, \\
    \fdef{outputParameters}{\st{RustExpression}^\infty},
  }
}

\std{Declaration}{
  \StructS{
    \fdef{name}{\str}, \\
    \fdef{type}{\st{Type}}
  }
}

Declaration of a variable. Useful, for example, to translate local variables.


\std{Block}{
  \StructS{
    \fdef{instructions}{\st{RustInstruction}^\infty}
  }
}

It just consist of nested instructions. Useful, for example, to translate local variables definition.

\std{RustAssignement}{
  \StructS{
    \fdef{variable}{\st{Variable}}, \\
    \fdef{expression}{\st{RustExpression}}
  }
}


\std{RustExpression}{\st{Int} \cup \st{Bool} \cup \st{Variable} \cup \st{RustBinaryExpression} \cup \st{RustArray}}


\std{Int}{\StructS{
    \fdef{value}{\tint}
  } = \st{Integer\_Literal}}

\std{Bool}{\StructS{
    \fdef{value}{\bool}
  }}

\std{Variable}{\st{LocalVariable} \cup \st{GlobalVariable} \cup \st{ParameterVariable}}

\std{LocalVariable}{
  \StructS{
    \fdef{name}{\str}
  }
}

\std{GlobalVariable}{
  \StructS{
    \fdef{name}{\str}
  }
}


\std{ParameterVariable}{
  \StructS{
    \fdef{name}{\str}
  }
}

A variable which is a parameter of the function it is defined in. If they are translated by references, a variable usage should be dereferenced.


\std{RustArray}{
  \StructS{
    \fdef{values}{\st{RustExpression}^\infty} \\
  }
}


\std{RustBinaryExpression}{
  \StructS{
    \fdef{left\_expr}{\st{RustExpression}}, \\
    \fdef{type}{\st{binaryExpression}}, \\
    \fdef{right\_expr}{\st{RustExpression}}
  }
}

\std{binaryExpression}{\left\{\ulobj{addition}, \ulobj{substraction}, \ulobj{division}, \ulobj{multiplication}, \ulobj{exponentiation}, \ulobj{modulo}, \ulobj{tabularPosition}\right\}}


\std{RustIf}{
  \StructS{
    \fdef{predicate}{\st{RustPredicate}}, \\
    \fdef{then\_instr}{\st{RustInstruction}^\infty}, \\
    \fdef{else\_instr}{\st{RustInstruction}^\infty}
  }
}


\std{RustPredicate}{\st{RustBinaryPredicate} \cup \st{RustPredicateAggregate} \cup \st{RustUnaryPredicate}}


\std{RustBinaryPredicate}{
  \StructS{
    \fdef{left\_expr}{\st{RustExpression}}, \\
    \fdef{symbol}{\st{comparisonSymbol}}, \\
    \fdef{right\_expr}{\st{RustExpression}}
  }
}


\std{comparisonSymbol}{\left\{\ulobj{LessThan}, \ulobj{LessThanOrEqualTo}, \ulobj{EqualTo}, \ulobj{NotEqualTo}, \ulobj{MoreThanOrEqualTo}, \ulobj{MoreThan}, \ulobj{And}, \ulobj{Or}\right\}}


\std{RustPredicateAggregate}{
  \StructS{
    \fdef{predicates}{\st{RustPredicate}^\infty}, \\
    \fdef{symbol}{\st{comparisonSymbol}}
  }
}

\std{RustUnaryPredicate}{
  \StructS{
    \fdef{predicate}{\st{RustPredicate}}
  }
}


\std{Function}{
  \StructS{
    \fdef{name}{\str}, \\
    \fdef{inputParameters}{\mathbb{P}(\str \times \st{Types})}, \\
    \fdef{outputParameters}{\mathbb{P}(\str \times \st{Types})}, \\
    \fdef{instructions}{\st{RustInstruction}^\infty}
  }
}


\std{Context}{
  \StructS{
    \fdef{parameters}{\str^\infty}, \\
    \fdef{global}{\str^\infty}, \\
    \fdef{instancesNameAssoc}{(\str \times \str)^\infty}, \\
    \fdef{operationNameAssoc}{(\str \times \str)^\infty}
  }
}

The context helps during the translation to keep an eye on several relevant information translated before the current translation unit (for example, list of local defined variables, list of instance names in {\br}...)


\subsection{$\mathcal{S}_\text{Rust}$}

\[
  \mathcal{S}_{\text{Rust}} = \OStructS{
    \fdef{mods}{\st{\_mod}^\infty}, \\
    \fdef{uses}{\st{\_use}^\infty}, \\
    \imfdef{\left\{\rtext{\#[derive(Default)]\CR}\right.} \\
    \imfdef{\left.\rtext{pub struct }\right\},} \\
    \fdef{name\textsubscript{1}}{\str}, \\
    \imfdef{\left\{\rtext{ \{\CR}\right.,} \\
    \imfdef{\left.\rtext{// Instances of imported modules.\CR}\right\},} \\
    \fdef{instances}{\st{\_instance}^\infty}, \\
    \imfdef{\left\{\rtext{{\CR}// Concrete variables \& constants.\CR}\right\},} \\
    \fdef{variables}{\st{\_variableDeclaration}^\infty}, \\
    \imfdef{\left\{\rtext{\}\CR{\CR}impl }\right\},} \\
    \fdef{name\textsubscript{2}}{\str}, \\
    \imfdef{\left\{\rtext{ \{{\CR}}\right.} \\
    \imfdef{\left.\rtext{pub fn initialisation(\&mut self) \{\CR}\right.,} \\
    \imfdef{\left.\rtext{// Instances of imported modules initialization.\CR}\right\},} \\
    \fdef{instances\_init}{\st{\_instance\_init}^\infty}, \\
    \imfdef{\left\{\rtext{\CR// Constant’s `VALUES`.\CR}\right\},} \\
    \fdef{values}{\st{\_instruction}^\infty}, \\

    \imfdef{\left\{\rtext{\CR// `INITIALISATION` clause.\CR}\right\},} \\
    \fdef{initialisations}{\st{\_instruction}^\infty}, \\
    \imfdef{\left\{\rtext{\}\CR}\right\},} \\
    \fdef{functions}{\st{\_function}^\infty}, \\
    \imfdef{\left\{\rtext{\}\CR}\right\}}
  }
\]


\std{\_mod}{
  \OStructS{
    \imfdef{\{\rtext{mod }\},} \\
    \fdef{name}{\str}, \\
    \imfdef{\{\rtext{;\CR}\}}
  }
}


\std{\_use}{
  \OStructS{
    \imfdef{\{\rtext{use }\},} \\
    \fdef{name}{\str}, \\
    \imfdef{\{\rtext{;\CR}\}}
  }
}


\std{\_instance}{
  \OStructS{
    \fdef{instanceName}{\str}, \\
    \imfdef{\{\rtext{: }\},} \\
    \fdef{name\textsubscript{1}}{\str}, \\
    \imfdef{\{\rtext{::}\},} \\
    \fdef{name\textsubscript{2}}{\str}, \\
    \imfdef{\{\rtext{,\CR}\}}
  }
}


The prefix \rtext{r\#} aims at allowing usage of Rust keywords as variable names; it is an escape sequence.

\std{\_variableDeclaration}{
  \OStructS{
    \imfdef{\{\rtext{r\#}\},} \\
    \fdef{name}{\str}, \\
    \imfdef{\{\rtext{: }\},} \\
    \fdef{type}{\st{\_type}}, \\
    \imfdef{\{\rtext{,\CR}\}}
  }
}


\std{\_type}{
  \{\rtext{i32}, \rtext{i16}, \rtext{i8}, \rtext{bool}\} \cup \st{\_tabular}
}

\std{\_tabular}{
  \OStructS{
    \imfdef{\{\rtext{[}\},} \\
    \fdef{type}{\st{\_type}}, \\
    \imfdef{\{\rtext{; }\},} \\
    \fdef{size}{\mathbb{Z}}, \\
    \imfdef{\{\rtext{]}\}}
  }
}

\std{\_instruction}{
  \st{\_assignement} \cup \st{\_if} \cup \st{\_functionCall} \cup \st{\_while}
}

\std{\_while}{
  \OStructS{
    \imfdef{\{\rtext{while }\},} \\
    \fdef{condition}{\st{\_predicate}}, \\
    \imfdef{\{\rtext{ \{{\CR}}\},} \\
    \fdef{instructions}{\st{\_instruction}^\infty}, \\
    \imfdef{\{\rtext{\}{\CR}}\}} \\
  }
}

\std{\_functionCall}{
  \OStructS{
    \fdef{inits}{\st{\_functionCallInit}^\infty}, \\
    \imfdef{\{\rtext{self.}\},} \\
    \fdef{instanceName}{\str}, \\
    \imfdef{\{\rtext{.}\},} \\
    \fdef{functionName}{\str}, \\
    \imfdef{\{\rtext{(}\},} \\
    \fdef{inputParameters}{\st{\_functionCallInputParameter}^\infty}, \\
    \fdef{outputParameters}{\st{\_functionCallOutputParameter}^\infty}, \\
    \imfdef{\{\rtext{);\CR}\},} \\
  }
}


Initialization for output parameters (because Rust doesn’t allow usage of uninitialized output parameters).

\std{\_functionCallInit}{
  \OStructS{
    \imfdef{\{\rtext{self.}\},} \\
    \fdef{instanceName}{\str}, \\
    \imfdef{\{\rtext{ = Default::default();\CR}\},} \\
  }
}


\std{\_functionCallInputParameter}{
  \OStructS{
    \imfdef{\{\rtext{\&}\},} \\
    \fdef{expression}{\st{\_expr}}, \\
    \imfdef{\{\rtext{,}\},} \\
  }
}


Output parameters are mutable borrows.

\std{\_functionCallOutputParameter}{
  \OStructS{
    \imfdef{\{\rtext{\&mut }\},} \\
    \fdef{name}{\st{\_variable}}, \\
    \imfdef{\{\rtext{,}\},} \\
  }
}


\std{\_assignement}{
  \OStructS{
      \fdef{variable}{\str}, \\
      \imfdef{\{\rtext{ = }\},} \\
      \fdef{expr}{\st{\_expr}}, \\
      \imfdef{\{\rtext{;\CR}\}} \\
}  
}


\std{\_expr}{
  \st{\_int} \cup \st{\_bool} \cup \st{\_variable} \cup \st{\_binaryexpression} \cup \st{\_array}
}


\std{\_int}{
  \StructS{
    \fdef{value}{\tint}
  } = \st{Integer\_Literal} = \st{Int}
}

\std{\_bool}{
  \{\rtext{true}, \rtext{false}\}
}


\std{\_variable}{
  \st{\_localVariable} \cup \st{\_globalVariable} \cup \st{\_parameterVariable}
}

\std{\_localVariable}{
  \OStructS{
    \imfdef{\{\rtext{r\#}\},} \\
    \fdef{name}{\str}
  }
}


\std{\_globalVariable}{
  \OStructS{
    \imfdef{\{\rtext{self.r\#}\},} \\
    \fdef{name}{\str}
  }
}


They are necessarily borrows and need to be dereferenced first.

\std{\_parameterVariable}{
  \OStructS{
    \imfdef{\{\rtext{*r\#}\},} \\
    \fdef{name}{\str}
  }
}



\std{\_binaryexpression}{\st{\_classicbinaryexpression} \cup \st{\_exponentiation} \cup \st{\_tabularAccess}}

\std{\_classicbinaryexpression}{
  \OStructS{
    \imfdef{\{\rtext{(}\},} \\
    \fdef{left\_expr}{\st{\_expr}}, \\
    \fdef{type}{\st{\_binaryexprop}}, \\
    \fdef{right\_expr}{\st{\_expr}}, \\
    \imfdef{\{\rtext{)}\}}
  }
}


\std{\_binaryexprop}{
  \{\rtext{) + (}, \rtext{) - (}, \rtext{) * (}, \rtext{) / (}, \rtext{) \% (}\}
}


\std{\_tabularAccess}{
  \OStructS{
    \fdef{tabular}{\st{\_expr}}, \\
    \imfdef{\{\rtext{(}\},} \\
    \fdef{index}{\st{\_expr}}, \\
    \imfdef{\{\rtext{)}\}}
  }
}

The \texttt{tabular} is an \st{\_expr} because is could be itself a tabular access (case of a multiple dimensons tabular).


\std{\_exponentiation}{
  \OStructS{
    \imfdef{\{\rtext{(}\},} \\
    \fdef{left\_expr}{\st{\_expr}}, \\
    \imfdef{\{\rtext{).pow((}\},} \\
    \fdef{right\_expr}{\st{\_expr}}, \\
    \imfdef{\{\rtext{).try\_into().unwrap())}\}}
  }
}


\std{\_array}{
  \StructS{
    \imfdef{\{\rtext{[}\},} \\
    \fdef{values}{\st{\_arrayExpr}^\infty}, \\
    \imfdef{\{\rtext{]}\},}
  }
}


\std{\_arrayExpr}{
  \StructS{
    \fdef{value}{\st{\_expr}}, \\
    \imfdef{\{\rtext{, }\},}
  }
}


\std{\_if}{
  \OStructS{
    \imfdef{\{\rtext{if }\},} \\
    \fdef{predicate}{\st{\_predicate}}, \\
    \imfdef{\{\rtext{ \{\CR}\},} \\
    \fdef{then\_instr}{\st{\_instruction}^\infty}, \\
    \imfdef{\{\rtext{\} else \{\CR}\},} \\
    \fdef{else\_instr}{\st{\_instruction}^\infty}, \\
    \imfdef{\{\rtext{\}}\}}
  }
}


\std{\_predicate}{\st{\_binarypredicate} \cup \st{\_predicateaggregate} \cup \st{\_unarypredicate}}


\std{\_binarypredicate}{
  \OStructS{
    \fdef{leftexpr}{\st{\_expr}}, \\
    \fdef{symbol}{\st{\_comparisonop}}, \\
    \fdef{rightexpr}{\st{\_expr}}, \\
  }
}


\std{\_comparisonop}{\{\rtext{<}, \rtext{<=}, \rtext{=}, \rtext{>=}, \rtext{>}, \rtext{!=}\}}


\std{\_predicateaggregate}{
  \OStructS{
    \imfdef{\{\rtext{(}\},} \\
    \fdef{firstpredicate}{\st{\_predicate}}, \\
    \fdef{aggregates}{\st{\_nestedpredicateaggregate}^\infty}, \\
    \imfdef{\{\rtext{)}\}}
  }
}


\std{\_nestedpredicateaggregate}{
  \OStructS{
    \imfdef{\{\rtext{) }\},} \\
    \fdef{the\_symbol}{\st{\_predicateaggregateop}}, \\
    \imfdef{\{\rtext{ (}\},} \\
    \fdef{predicate}{\st{\_predicate}}
  }
}


\std{\_predicateaggregateop}{
  \{\rtext{\&\&}, \rtext{||}\}
}


\std{\_unarypredicate}{
  \OStructS{
    \imfdef{\{\rtext{!(}\},} \\
    \fdef{predicate}{\st{\_predicate}}, \\
    \imfdef{\{\rtext{)}\},} \\
  }
}


\std{\_instance\_init}{
  \OStructS{
    \imfdef{\{\rtext{self.}\},} \\
    \fdef{instanceName\textsubscript{1}}{\str}, \\
    \imfdef{\left\{\rtext{ = Default::default();\CR}\right.,} \\
    \imfdef{\left.\rtext{self.}\right\},} \\
    \fdef{instanceName\textsubscript{2}}{\str}, \\
    \imfdef{\left.\rtext{.initialisation();\CR}\right\},} \\
  }
}


\std{\_function}{
  \OStructS{
    \imfdef{\{\rtext{{\CR}fn }\},} \\
    \fdef{name}{\str}, \\
    \imfdef{\{\rtext{(\&mut self}\},} \\
    \fdef{inputParameters}{\st{\_inputParameter}^\infty}, \\
    \fdef{outputParameters}{\st{\_outputParameter}^\infty}, \\
    \imfdef{\{\rtext{) \{\CR}\},} \\
    \fdef{instructions}{\st{\_instruction}^\infty}, \\
    \imfdef{\{\rtext{\}\CR}\}}
  }
}

\std{\_inputParameter}{
  \OStructS{
    \imfdef{\left\{\rtext{, }\right\},} \\
    \fdef{name}{\str}, \\
    \imfdef{\left\{\rtext{: \&}\right\},} \\
    \fdef{type}{\st{\_type}} \\
  }
}

It is an immutable reference.

\std{\_outputParameter}{
  \OStructS{
    \imfdef{\left\{\rtext{, }\right\},} \\
    \fdef{name}{\str}, \\
    \imfdef{\left\{\rtext{: \&mut }\right\},} \\
    \fdef{type}{\st{\_type}} \\
  }
}


\subsection{From BXML to a converted shape}

{\br} translates each \texttt{Parser} into a module. In this section, we will give this translation’s scheme. A \texttt{Parser} can be seen as a couple of files: an abstract machine and an implementation. They can be seen as $a, i \in \mathcal{S}_\text{BXML}$ and the result of this translation, as $c \in \mathcal{S}_\text{converted}$.


\subsubsection{Definitions}

If $m$ is a characters string, we refer by $P_a(m) \in \mathcal{S}_\text{BXML}$ the parsed shape of an abstract machine of a B~module whose name is $m$ (so, found in the file \texttt{name.bxml} if \texttt{name} is the name of the module). We refer by $P_i(m) \in \mathcal{S}_\text{BXML}$ the parsed shape of the implementation.

Concerning the imports of a module, the name of the instance written in the Rust code is not the one provided in the B~code, because:
\begin{enumerate}
\item An import might not be renamed.
\item A concrete variable, for example, may have the same name as an "instance" ({\ie} an import rename).
\end{enumerate}

So, if our concrete variables and constants keep the same name, we need to add a prefix to our imports. We chose it to be \rtext{\_i\_}, where $i$ is a counter reset for each module; if there's no instance name given, the name of the module is taken. If $k$ is an natural number, the function $\nu_k$ give a {\br} instance name, given the B~instance name and the B~module name.

\fun{\nu_k}{
  \str \times \str \: \! & \longrightarrow \: \! & \str \\
  (\rtext{}, n) \: \! & \longmapsto \: \! & \rtext{\_} \cdot k \cdot \rtext{\_} \cdot n \\
  (r, n) & \longmapsto & \rtext{\_} \cdot k \cdot \rtext{\_} \cdot r \\
}


% The functions $T_{v, i}$ and $T_{c, i}$ associate the recognized type of a concrete variable or constant, given its \st{Exp} which is supposed to be an \st{Id}. An example is given later in this document.

% \begin{adjustbox}{center}
% \(
%   T_{v, i} \colon \left\{
%     \begin{array}{ccl}
%       i\sref{Concrete\_Variables} \: \! & \longrightarrow \: \! & \st{RecognizedType} \\
%       s \: \! & \longmapsto \: \! & \left\{ \begin{array}{lll}
%                                     \multicolumn{2}{l}{\text{if we define $e_c \in \st{Exp\_Comparison}$ such as:}} \\
%                                       \textsc{i}) & i\sref{Invariant}\sref{pred\_group} \in \st{Exp\_Comparison} \implies e_c = i\sref{Invariant}\sref{pred\_group} \\
%                                       \textsc{ii}) & i\sref{Invariant}\sref{pred\_group} \notin \st{Exp\_Comparison} \implies e_c \in i\sref{Invariant}\sref{pred\_group} \\
%                                       \textsc{iii}) & e_c\sref{Exp}_1 \in \st{Id} \\
%                                       \textsc{iv}) & e_c\sref{Exp}_1 = s \\
%                                       \textsc{v}) & e_c\sref{Exp}_2 \in \st{RecognizedType} \\
%                                       \textsc{vi}) & e_c\sref{op} = \rtext{:}, \\
%                                       \multicolumn{2}{l}{\text{then, $e_c\sref{Exp}_2\sref{value}$.}}
%                                     \end{array} \right.
%     \end{array}
%   \right.
% \)
% \end{adjustbox}

% \begin{adjustbox}{center}
% \(
%   T_{c, i} \colon \left\{
%     \begin{array}{ccl}
%       i\sref{Concrete\_Constants} \: \! & \longrightarrow \: \! & \st{RecognizedType} \\
%       s \: \! & \longmapsto \: \! & \left\{ \begin{array}{lll}
%                                     \multicolumn{2}{l}{\text{if we define $e_c \in \st{Exp\_Comparison}$ such as:}} \\
%                                       \textsc{i}) & i\sref{Properties}\sref{pred\_group} \in \st{Exp\_Comparison} \implies e_c = i\sref{Properties}\sref{pred\_group} \\
%                                       \textsc{ii}) & i\sref{Properties}\sref{pred\_group} \notin \st{Exp\_Comparison} \implies e_c \in i\sref{Properties}\sref{pred\_group} \\
%                                       \textsc{iii}) & e_c\sref{Exp}_1 \in \st{Id} \\
%                                       \textsc{iv}) & e_c\sref{Exp}_1 = s \\
%                                       \textsc{v}) & e_c\sref{Exp}_2 \in \st{RecognizedType} \\
%                                       \textsc{vi}) & e_c\sref{op} = \rtext{:}, \\
%                                       \multicolumn{2}{l}{\text{then, $e_c\sref{Exp}_2\sref{value}$.}}
%                                     \end{array} \right.
%     \end{array}
%   \right.
% \)
% \end{adjustbox}

% The function $T$ is very close to the two latter ones and theses different versions are kept because there is still legacy code in {\br}.

Remember the grammar \gram{RecognizedType}; we need to represent it as a subset of $\mathcal{S}_\text{BXML}$ to use it in our translation scheme. So, $\st{RecognizedType}$ is the set of expressions which are legit types you can give to your variables.

\std{RecognizedType}{
  \begin{array}{l}
    \left\{i \mid i \in \st{Id}, i\sref{value} \in \left\{\rtext{rust\_i8}, \rtext{rust\_i16}, \rtext{rust\_i32}, \rtext{rust\_bool}\right\} \right\} \cup \\
    \left\{b \mid b \in \st{Binary\_Exp}, \left\{
    \begin{array}{rl}
      b\sref{exp}_1 &\in \left\{
      n \mid n \in \st{Binary\_Exp}, \left\{
      \begin{array}{rl}
        n\sref{exp}_1 &\in \st{Integer\_Literal}, \\
        n\sref{exp}_1\sref{value} &= 0, \\
        n\sref{exp}_2 &\in \st{Integer\_Literal}, \\
        n\sref{op} &= \rtext{..}
      \end{array}
      \right\}
      \right\}, \\
      b\sref{exp}_2 &\in \st{RecognizedType} \\
      b\sref{op} &= \rtext{-->}, \\
    \end{array}
    \right\}
    \right\}
  \end{array}
}

$T$ takes as argument a variable name and a \st{pred\_group} and associates a string which is the type of the variable defined inside the predicate.

\fun{T}{
  \str \times \st{pred\_group} \: \! & \longrightarrow \: \! & \st{RecognizedType} \\
  (v, p) \: \! & \longmapsto \: \! & \left\{
    \begin{array}{ll}
      \multicolumn{2}{l}{\text{if we can define $e_c \in \st{Exp\_Comparison}$ such as:}} \\
      \textsc{i}) & p \in \st{Exp\_Comparison} \implies e_c = p, \\
      \textsc{ii}) & p \notin \st{Exp\_Comparison} \implies e_c \inplus p\sref{pred\_group}, \\
      \textsc{iii}) & e_c\sref{Exp}_1 \in \st{Id}, \\
      \textsc{iv}) & e_c\sref{Exp}_1\sref{value} = s, \\
      \textsc{v}) & e_c\sref{Exp}_2 \in \st{RecognizedType}, \\
      \textsc{vi}) & e_c\sref{op} = \rtext{:}, \\
      \multicolumn{2}{l}{\text{then, $e_c\sref{Exp}_2\sref{value}$.}} \\
      \multicolumn{2}{l}{\text{Else, an unspecified value.}} \\
    \end{array} \right.
}


The function $\tau_T$, defined below, translate a BXML \st{RecognizedType} into a converted-shaped \st{Type}. According to the B specification, if the total function domain is an interval from $0$ to $a$ where $a \leq -1$, the array is empty.

\begin{adjustbox}{center}
\(
  \tau_T \colon \left\{
    \begin{array}{ccl}
      \st{RecognizedType} & \longrightarrow & \st{Type} \\
      \Struct{\rtext{rust\_i8}} & \longmapsto & \ulobj{i8\_t} \\
      \Struct{\rtext{rust\_i16}} & \longmapsto & \ulobj{i16\_t} \\
      \Struct{\rtext{rust\_i32}} & \longmapsto & \ulobj{i32\_t} \\
      \Struct{\rtext{rust\_bool}} & \longmapsto & \ulobj{bool\_t} \\
      \OStruct{(\OStruct{
      (\cdot, e_2'), \rtext{..}
      }, e_2), \rtext{-->}} \text{ if $e_2'\sref{value} \geq -1$} & \longmapsto & \Struct{
                                            \fot{size}{e_2'\sref{value} + 1}, \\
      \fot{elementsType}{\tau_T(e_2)}
      }\\
      \OStruct{(\OStruct{
      (\cdot, \cdot), \rtext{..}
      }, e_2), \rtext{-->}} \text{ elsewise} & \longmapsto & \Struct{
                                                                                  \fot{size}{0}, \\
      \fot{elementsType}{\tau_T(e_2)}
      }\\

    \end{array}
  \right.
\)
\end{adjustbox}

The functions $\tau_\text{bool}$, $\tau_\text{binexp}$, $\tau_\text{id}$, $\tau_\text{naryexp}$, $\tau_\text{exp}$, defined below, translate a boolean, a binary expression, a variable, an expression with multiple members, and, globally, an expression, respectively. The translation functions for integer and variables are not defined, because mathematically, they refer to the same objects. Note that $\tau_\text{exp}$ (and several other translation functions such as the one for predicates and instructions) also take a context as argument. This is needed by the $\tau_\text{id}$ function which needs to know the parameters of the operation it is in, so, it needs to be carried out for the functions which may nest an \st{Id}.

\[
  \tau_\text{bool} \colon \left\{
    \begin{array}{ccl}
      \st{Boolean\_Literal} & \longrightarrow & \bool \\
      b & \longmapsto & b\sref{value}
    \end{array}
  \right.
\]

\[
  \tau_\text{binexp} \colon \left\{
    \begin{array}{ccl}
      \st{Binary\_Exp} \times \st{Context} & \longrightarrow & \st{RustBinaryExpression} \\
      \left(\OStruct{(e_1, e_2), o}, t\right) & \longmapsto & \Struct{\fot{left\_expr}{\tau_\text{exp}(e_1, t)}, \\ \fot{type}{\tau_\text{binexpop}(o)}, \\ \fot{right\_expr}{\tau_\text{exp}(e_2, t)}}
    \end{array}
  \right.
\]

The function $\tau_\text{binexp}$ uses a translation for the symbols:
\[
  \tau_\text{binexpop} \colon \left\{
    \begin{array}{ccl}
      \st{binary\_exp\_op} & \longrightarrow & \st{binaryExpression} \\
      \rtext{+i} & \longmapsto & \ulobj{addition} \\
      \rtext{-i} & \longmapsto & \ulobj{substraction} \\
      \rtext{*i} & \longmapsto & \ulobj{multiplication} \\
      \rtext{/i} & \longmapsto & \ulobj{division} \\
      \rtext{mod} & \longmapsto & \ulobj{modulo} \\
      \rtext{**i} & \longmapsto & \ulobj{exponentiation} \\
      \rtext{(} & \longmapsto & \ulobj{tabularPosition} \\
      \cdot & \longmapsto & \cdot \\
    \end{array}
  \right.
\]


\fun{\tau_\text{naryexp}}{
  \st{Nary\_Exp} \times \st{Context} & \longrightarrow & \st{RustArray} \\
  \left(\OStruct{\left(
        \OStruct{
          (e_1^1, e_2^1), \\
          \cdot}, \cdots, \OStruct{(e_1^n, e_2^n), \\\cdot}\right), \\ \cdot}, t\right) & \longmapsto & \left\{
    \begin{array}{l}
      \text{if we define:} \\
      f \colon \left\{
      \begin{array}{ccl}
        \mathbb{N} &\longrightarrow &\st{Exp} \\
        e_1^\kappa &\longmapsto & e_2^\kappa
      \end{array}
      \right\} \text{, then,} \\
      \OStruct{\left(\tau_\text{exp}(f(0), t), \cdots, \tau_\text{exp}(f(n), t)\right)}
    \end{array}
    \right.
}

According to \hyperref[subset]{the specification} of the BXML files, a \st{Nary\_Exp} is always expected to be a relation definition ($\textsf{op} = \rtext{\{}$); its inner \st{Exp}'s are assumed to be \st{Binary\_Exp} whose \textsf{op} is \rtext{|->}; the left members are assumed to be \st{Integer\_Literal}s; for any small enough integer $k$, the \st{Nary\_Exp} defines a maplet associated to $k$ (if $k = 6$, for example, the B~code associated to this \st{Nary\_Exp} may contain \texttt{6 |-> 67 + ii}). So, we can define a function (called $f$ in the equation above) which associates the contained expression to every small enough integer.

\fun{\tau_\text{id}}{
  \st{Id} \times \st{Context} & \longrightarrow & \st{Variable} \\
  (d, t) \text{ if $d\sref{value} \in t\sref{global}$}& \longmapsto & \Struct{d\sref{value}} \in \st{GlobalVariable} \\
  (d, t) \text{ if $d\sref{value} \in t\sref{parameters}$}& \longmapsto & \Struct{d\sref{value}} \in \st{ParameterVariable} \\
  (d, t) \text{ otherwise} & \longmapsto & \Struct{d\sref{value}} \in \st{LocalVariable} \\
}

We need to have more information on the variable (and this is the reason why carring the context variable is useful) to translate it. This is because if the variable is a global variable or constant, it is translated as beeing a part of the \texttt{struct} and therefore needs to have a leading \texttt{self.}; if it is an operation parameter, it is a reference and we need to dereference it using a star.

\[
  \tau_\text{exp} \colon \left\{
    \begin{array}{ccl}
      \st{Exp} \times \st{Context} & \longrightarrow & \st{RustExpression} \\
      (e \in \st{Integer\_Literal}, \cdot) & \longmapsto & e \\
      (e \in \st{Boolean\_Literal}, \cdot) & \longmapsto & \tau_\text{bool}(e) \\
      (e \in \st{Id}, t) & \longmapsto & \tau_\text{id}(e, t) \\
      (e \in \st{Binary\_Exp}, t) & \longmapsto & \tau_\text{binexp}(e, t) \\
      (e \in \st{Nary\_Exp}, t) & \longmapsto & \tau_\text{naryexp}(e, t) \\
      \cdot & \longmapsto & \bot
    \end{array}
  \right.
\]

Then, we can define the function $\tau_\text{val}$ which translates a valuation into an instruction:
\[
  \tau_\text{val} \colon \left\{
    \begin{array}{ccl}
      \st{Valuation} \times \st{Context} & \longrightarrow & \st{RustAssignement} \\
      \left(\Struct{\fot{ident}{s}, \\ \fot{Exp}{(e_1, \cdots, e_n)}}, t\right) & \longmapsto & \Struct{\fot{variable}{\tau_\text{id}(s, t)}, \\ \fot{expression}{\tau_\text{exp}(e_1, t)}}
    \end{array}
  \right.
\]

% As this function is only used in the initialization clause, there is no context (no function parameter). So, the context needs to initialized to $\{\}$. The same remarks goes for some other cases.

We also define the function $\tau_\text{op}$ which translates an operation:

\fun{
  \tau_\text{op}
}{
  \st{Operation} \times \st{Context} & \longrightarrow & \st{Function} \\
  \left(\OStruct{o, u, r, b, n}, e\right) & \longmapsto &
  \left\{
  \begin{array}{ll}
    \text{if we define:} \\
    r' \in a\sref{Operations} & \text{such as} \\
    \multicolumn{2}{c}{r'\sref{name} = n,} \\
    e' \in \st{Context} & \text{such as} \\
    \multicolumn{2}{c}{\left\{
    \begin{array}{ll}
    e'\sref{global} &= e\sref{global}, \\
    e'\sref{parameters} &= \left\{
                          g \mid \exists d \inplus o \cup u, g = d\sref{value}
                          \right\}
    \end{array}
    \right.} \\
    \text{then,} \\
    \multicolumn{2}{c}{\OStruct{
    \fot{name}{n}, \\
    \fot{inputParameters}{\left\{
    (s, t) \mid \exists d \inplus o, s = d\sref{value}, t = \tau_T(T(s, r'))
    \right\}}, \\
    \fot{outputParameters}{\left\{
    (s, t) \mid \exists d \inplus u, s = d\sref{value}, t = \tau_T(T(s, r'))
    \right\}}, \\
    \fot{instructions}{
    \tau_\text{inst}((), b, e')
    }
    }}
  \end{array}
  \right.
}

For the sake of clarity, let us detail this using natural language.

\begin{itemize}
\item If we want to convert the input/output parameters, we need to know their types. The user needs to do it in the \texttt{Precondition} part of the operation, which is forbidden in the implementation. The function $\tau_\text{op}$ is used to translate implemented operations, of course, so, we need to search for the precondition of the abstraction of the operation (it is $r'$). Note that \textbf{the operation abstraction is identified by its name, because two operation cannot have the same name in B} (unless one is a rafinement of the other).
\item $e'$ is the context. It contains the global variables $\tau_\text{op}$ takes as argument, but it defines the list of parameters, so, the variables names are searched in $o \cup u$.
\item Some "BXML instructions" (such as \st{Nary\_Sub}, for example) can be translated into multiple "Rust instructions". As benefit, a lot of BXML instructions are merged into Rust instructions, so, there are much less Rust instructions than BXML instructions. The function $\tau_\text{inst}$, defined below, takes as argument a tuple of \st{RustInstruction} and an instruction; it returns a completed tuple of \st{RustInstruction}. In the function $\tau_\text{op}$, $\tau_\text{inst}$ is called with an empty tuple of $\st{RustInstruction}$.
\end{itemize}

\[
  \tau_\text{inst} \colon \left\{
    \begin{array}{clcl}
      \multicolumn{2}{c}{\st{RustInstruction}^\infty \times \st{Sub} \times \st{Context}} & \longrightarrow & \st{RustInstruction}^\infty \\
      (i, s, o), &s \in \st{Assert\_Sub}  & \longmapsto & \tau_\text{assert}(i, s, o) \\
      (i, s, o), &s \in \st{Assignement\_Sub} & \longmapsto & \tau_\text{assignment}(i, s, o) \\
      (i, s, o), &s \in \st{Becomes\_In}  & \longmapsto & \tau_\text{becomesin}(i, s, o) \\
      (i, s, o), &s \in \st{If\_Sub}  & \longmapsto & \tau_\text{if}(i, s, o) \\
      (i, s, o), &s \in \st{Nary\_Sub}  & \longmapsto & \tau_\text{narysub}(i, s, o) \\
      (i, s, o), &s \in \st{Operation\_Call}  & \longmapsto & \tau_\text{operationcall}(i, s, o) \\
      (i, s, o), &s = \ulobj{Skip}  & \longmapsto & i \\
      (i, s, o), &s \in \st{VAR\_IN}  & \longmapsto & \tau_\text{varin}(i, s, o) \\
      (i, s, o), &s \in \st{While}  & \longmapsto & \tau_\text{while}(i, s, o) \\
      \multicolumn{2}{c}{\cdot} & \longmapsto & \cdot
    \end{array}
  \right.
\]


With the following definitions:


\fun{\tau_\text{operationcall}}{
  \st{RustInstruction}^\infty \times \st{Operation\_Call} \times \st{Context} & \longrightarrow & \st{RustInstruction}^\infty \\
  \left((i_1, \cdots, i_n), s, o\right) \text{ if $s\sref{name}\sref{id}\sref{instance}$} = \rtext{}
  & \longmapsto & \left\{
    \begin{array}{l}
      \text{if we define:} \\
      v = s\sref{name}\sref{id}\sref{value}, \\
      (v, t) \text{ such as } (v, t) \in o\sref{operationsNameAssoc}, \\
      \text{then:} \\
      \left(
      i_1, \cdots, i_n, \Struct{
      \fot{moduleName}{t}, \\
      \fot{functionName}{v}, \\
      \fot{inputParameters}{\lambda_{i, s}}, \\
      \fot{inputParameters}{\lambda_{o, s}}, \\
      }
      \right)
    \end{array}
  \right. \\
  
  \left((i_1, \cdots, i_n), s, o\right) \text{ elsewise}
  & \longmapsto & \left\{
    \begin{array}{l}
      \text{if we define:} \\
      t = s\sref{name}\sref{id}\sref{instance}, \\
      (t, \alpha) \text{ such as } (t, \alpha) \in o\sref{instancesNameAssoc}, \\
      \text{then:} \\
      \left(
      i_1, \cdots, i_n, \Struct{
      \fot{moduleName}{\alpha}, \\
      \fot{functionName}{s\sref{name}\sref{id}\sref{component}}, \\
      \fot{inputParameters}{\lambda_{i, s}}, \\
      \fot{inputParameters}{\lambda_{o, s}}, \\
      }
      \right)
    \end{array}
  \right.
}

where:
\begin{align*}
  \lambda_{i, s} &= (\tau_\text{exp}(s\sref{inputParameters}\sref{exp}_1), \cdots, \tau_\text{exp}(s\sref{inputParameters}\sref{exp}_n)) \\
  \lambda_{o, s} &= (\tau_\text{exp}(s\sref{outputParameters}\sref{exp}_1), \cdots, \tau_\text{exp}(s\sref{outputParameters}\sref{exp}_n))
\end{align*}

Explanations:
\begin{itemize}
\item If the complete operation name ($s\sref{name}\sref{id}\sref{value}$) is precedated by a renamed instance (second case), we just need to find the name of the instance {\br} associated. Therefore, we use the object \texttt{instancesNameAssoc} in the context. The operation name is called \texttt{component} is the BXML file.
\item Elsewise, {\ie} if no instance name is given, it is more difficult as we need to "guess" the instance the operation is in (the BXML contains not enough information). We use the \texttt{operationsNameAssoc} which is completed elsewhere.
\end{itemize}


\fun{\tau_\text{narysub}}{
  \st{RustInstruction}^\infty \times \st{Nary\_Sub} \times \st{Context} & \longrightarrow & \st{RustInstruction}^\infty \\
  \left(l, s, o\right)
  & \longmapsto &
  \tau_\text{inst}(\cdots \tau_\text{inst}(\tau_\text{inst}(l, s\sref{Sub}_1, o), s\sref{Sub}_2, o) \cdots, s\sref{Sub}_n, o)
}

\[
  \tau_\text{assert} \colon \left\{
    \begin{array}{ccl}
      \st{RustInstruction}^\infty \times \st{Assert\_Sub} \times \st{Context} & \longrightarrow & \st{RustInstruction}^\infty \\
      (l, \OStruct{g, b}, o) & \longmapsto & \tau_\text{inst}(l, b, o)
    \end{array}
    \right.
  \]

  It just ignores the guard.

\fun{
\tau_\text{assignment}
}{
        \st{RustInstruction}^\infty \times \st{Assignement\_Sub} \times \st{Context} & \longrightarrow & \st{RustInstruction}^\infty \\
      ((i_1, \cdots, i_n), b, o)  & \longmapsto & \left(i_1, \cdots, i_n, \Struct{\fot{variable}{\tau_\text{exp}(b\sref{Variables}_1, o)}, \\ \fot{expression}{\tau_\text{exp}(b\sref{Values}_1, o)}}\right)
}

\fun{
  \tau_\text{if}
}{
  \st{RustInstruction}^\infty \times \st{If\_Sub} \times \st{Context} & \longrightarrow & \st{RustInstruction}^\infty \\
  \left((i_1, \cdots, i_n), s, o\right)  & \longmapsto & \left(i_1, \cdots, i_n, \Struct{
      \fot{predicate}{\tau_\text{pred}(s\sref{Condition}, o)}, \\
      \fot{then\_instr}{\tau_\text{inst}((), s\sref{Then}, o)}, \\
      \fot{else\_instr}{\tau_\text{inst}((), s\sref{Else}, o)}
    } \right)
}

And also:

\begin{adjustbox}{center}
  \(
  \tau_\text{pred} \colon \left\{
    \begin{array}{ccl}
      \st{predicate\_type} \times \st{Context} & \longrightarrow & \st{RustPredicate} \\
      \left(\OStruct{(e_1, e_2), o} \in \st{Exp\_Comparison}, n\right) & \longmapsto & \Struct{
                                                                     \fot{left\_expr}{\tau_\text{exp}(e_1, n)}, \\
      \fot{symbol}{\tau_\text{comparisonexp}(o)}, \\
      \fot{right\_expr}{\tau_\text{exp}(e_2, n)}
      } \\
      \left(\Struct{
      \fot{pred\_group}{(p_1, \cdots, p_n)}, \\
      \fot{op}{o} \\
      } \in \st{Nary\_Pred}, n\right) & \longmapsto & \Struct{
                              \fot{predicates}{
                              (\tau_\text{pred}(p_1, n), \cdots, \tau_\text{pred}(p_n, n))}, \\
      \fot{symbol}{\tau_\text{comparisonexp}(o)}
      
      } \\
      \left(d \in \st{Unary\_Pred}, n\right) & \longmapsto & \Struct{
                        \tau_\text{pred}(d\sref{pred\_group}, n)
                                             } \\
      \cdot & \longmapsto & \cdot
    \end{array}
  \right.
  \)
  \end{adjustbox}

The translation function used is:
\[
  \tau_\text{comparisonexp} \colon \left\{
    \begin{array}{ccl}
      \st{comparison\_op} & \longrightarrow & \st{comparisonSymbol} \\
      \rtext{<i} & \longmapsto & \ulobj{LessThan} \\
      \rtext{<=i} & \longmapsto & \ulobj{LessThanOrEqualTo} \\
      \rtext{=} & \longmapsto & \ulobj{EqualTo} \\
      \rtext{/=} & \longmapsto & \ulobj{NotEqualTo} \\
      \rtext{>=i} & \longmapsto & \ulobj{MoreThanOrEqualTo} \\
      \rtext{>i} & \longmapsto & \ulobj{MoreThan} \\
      \rtext{\&} & \longmapsto & \ulobj{And} \\
      \rtext{or} & \longmapsto & \ulobj{Or} \\
      \cdot & \longmapsto & \ulobj{MoreThan} \\
    \end{array}
  \right.
\]


\fun{
  \tau_\text{becomesin}
}{
  \st{RustInstruction}^\infty \times \st{Becomes\_In} \times \st{Context} & \longrightarrow & \st{RustInstruction}^\infty \\
  ((i_1, \cdots, i_n), s, \cdot) & \longmapsto & \left(i_1, \cdots, i_n, \Struct{
    \fot{name}{s\sref{Variables}\sref{\_Id}_1\sref{value}}, \\
    \fot{type}{\tau_T(s\sref{Value}\sref{\_exp}\sref{value})}
  }\right)
}

A \texttt{Becomes\_In} instruction is translated by a declaration of a new variable, so, for example, \texttt{temp1 :: rust\_bool} would be translated by the Rust code \texttt{let temp1: bool;}. The checker (which is specified in the section~\ref{subset}) ensures a \texttt{Becomes\_In} instruction shall never appear outside the very first elements of a \texttt{VAR\_IN}, so, these instruction will be valid. This is also the reason why the context is useless: a declaration is nothing more than a declaration.

\fun{
  \tau_\text{varin}
}{
  \st{RustInstruction}^\infty \times \st{VAR\_IN} \times \st{Context} & \longrightarrow & \st{RustInstruction}^\infty \\
  \left(l, s, o\right) & \longmapsto & \tau_\text{inst}(l, s\sref{Body}, o)
}

The translation is very simple because the local variables declarations are directly inside the \texttt{Body}: according to \hyperref[subset]{the recognized language}, which the checker checks, if $n$ local variables are defined, the $n$ first instructions must be \texttt{Becomes\_In}. These instruction will be translated like any other one.

\fun{
  \tau_\text{while}
}{
  \st{RustInstruction}^\infty \times \st{While} \times \st{Context} & \longrightarrow & \st{RustInstruction}^\infty \\
  \left((i_1, \cdots, i_n), \OStruct{d, b, \cdot, \cdot}, o\right) & \longmapsto & \left(
    i_1, \cdots, i_n, \Struct{
      \fot{condition}{\tau_\text{pred}(d)}, \\
      \fot{instructions}{\tau_\text{inst}(\{\}, b, o)}
    }
  \right)
}


\subsubsection{Properties verified by $a$, $i$ and $c$}
\label{conversion}

Let us define $n_v$ the number of valuations: $n_v = \lvert i\sref{Values} \rvert$.

Then, $a$, $i$ and $c$ verify the following properties:

\begin{enumerate}
\item The $c\sref{mods}$ only concerns the entry module: it has to define every recursive subimport. So, if $(a, i)$ is not the entry module, $c\sref{mods} = \varnothing$, and if it is:
  
  \begin{adjustbox}{center}
    \(
    c\sref{mods} = \left\{ s \mid \exists i_2, \cdots, i_n \in \mathcal{S}_\text{BXML},
      \left\{        
      \begin{array}{l}
        \left\{
        \begin{array}{l}
          \forall k \in \{2, \cdots, n-1\}, \\
          \exists j \{1, \cdots, \lvert i_k\sref{Imports}\sref{Referenced\_Machine} \rvert\}, \\
          i_{k+1} = P_i(i_k\sref{Imports}\sref{Referenced\_Machine}_j\sref{Name}) \\
        \end{array}
        \right. \\
        \left\{ \begin{array}{l}
          \exists j \{1, \cdots, \lvert i\sref{Imports}\sref{Referenced\_Machine} \rvert\}, \\
          i_2 = P_i(i\sref{Imports}\sref{Referenced\_Machine}_j\sref{Name})
                \end{array} \right. \\
        i_n = P_i(s)
      \end{array}
    \right. \right\}
    \)
  \end{adjustbox}
\item Contrary to $c\sref{mods}$, the $c\sref{uses}$ only concerns the modules which are not the entry module. It contains the imported modules (if the entry module imports modules, the \texttt{mod} keywords are sufficient). So, if $(a, i)$ is the entry module, $c\sref{uses} = \varnothing$, and if it is not:
  
  \begin{adjustbox}{center}
    \(
    c\sref{uses} = \left\{ s \mid \exists j, i\sref{Imports}\sref{Referenced\_Machine}_j\sref{Name} \right\}
    \)
  \end{adjustbox}  
\item The name is translated:
  \[
    c\sref{name} = i\sref{Abstraction}
  \]
  \item $c\sref{instances}$ contains the imported modules of the module, entry module or not.
  \begin{enumerate}
  \item There's exactly the imports of the implementation: $n \coloneq \lvert c\sref{instances} \rvert = \lvert i\sref{Imports}\sref{Referenced\_Machine} \rvert$.
  \item The instances are translated in order, and their name in the Rust code is renamed: $\forall k \i \{1, \cdots, n\}$, if we call $s_k = i\sref{Imports}\sref{Referenced\_Machine}_k$, then, $c\sref{instances}_k = (\nu_k(s_k\sref{Instance}), s_k\sref{Name})$.
  \end{enumerate}
\item Each concrete variable among the refinement chain is translated with its type:
  
  \begin{adjustbox}{center}
    \(
    \forall v \inplus a\sref{Concrete\_Variables} \cup i\sref{Concrete\_Variables}, \left(v\sref{value}, \tau_T\left( T(v\sref{value}, i\sref{Invariant}) \right)\right) \in c\sref{variables}
    \)
  \end{adjustbox}
\item Each concrete constant among the refinement chain is translated with its type:
  
  \begin{adjustbox}{center}
    \(
    \forall v \inplus a\sref{Concrete\_Constants} \cup i\sref{Concrete\_Constants}, \left(v\sref{value}, \tau_T\left( T(v\sref{value}, i\sref{Properties}) \right)\right) \in c\sref{variables}
    \)
  \end{adjustbox}
\item Conversely, each occurrence of a variable with its converted type in the converted object comes from a B concrete variable or B concrete constant with the same type:
  
  \begin{adjustbox}{center}
    \(
    \begin{array}{ll}
      \forall (v, t) \in c\sref{variables}, &v \inplus a\sref{Concrete\_Variables} \cup i\sref{Concrete\_Variables} \land \tau_T(T(v\sref{value}, i\sref{Invariant}) = t \lor \\
                                            &v \inplus a\sref{Concrete\_Constants} \cup i\sref{Concrete\_Constants} \land \tau_T(T(v\sref{value}, i\sref{Properties})) = t \\
    \end{array}
    \)
  \end{adjustbox}
\end{enumerate}

The next properties concern the initialisation, values, and functions translation.
% Please consider as part of the specification that \textbf{initialization and functions translations have to be done \textit{after} the translation of concrete variables or constants} (specified above).
Let us introduce the following context object:

\begin{adjustbox}{center}
  \(
  e = \Struct{
    \fot{global}{\{v \mid \exists k \in \{1 \cdots \lvert c\sref{variables} \rvert\}, v = c\sref{variables}_k\}}, \\
    \fot{parameters}{\{\}} \\
    \fot{instancesNameAssoc}{\left\{(t, r) \mid \exists k, \left\{
        \begin{array}{rl}
          t &= i\sref{Imports}\sref{Referenced\_Machine}_k\sref{Name}, \\
          r &= c\sref{instances}_{k, 1}
        \end{array}
        \right. \right\}}, \\
    \fot{operationsNameAssoc}{\left\{(o, n) \mid \left\{
          \begin{array}{l}
            \exists k, n = c\sref{instances}_{k, 1}, \\
            \exists p \in P_i(i\sref{Imports}\sref{Referenced\_Machine}_k\sref{Name})\sref{Operations}, \\
            o = p\sref{name}
          \end{array}
        \right. \right\}}
  }
  \)
\end{adjustbox}

which will be used in the next properties. \texttt{instancesNameAssoc} is a \texttt{map} which contains association between the instances name (like specified in the B~code) and the instance name {\br} gives (they don't match). \texttt{operationsNameAssoc} is a \texttt{map} which contains any couple of association between an operation name and a {\br} given instance name which matches a B~module imported by this implementation, and which wasn’t renamed (no instance name given). This is useful for the operations call translation.
  
\begin{enumerate}[resume]
\item $c\sref{instances\_init}$ contains the name of the instances of imported modules in the Rust code. It repeats the contents of $c\sref{instances}$. (It might seem useless, but it helps the conversion from a \texttt{RustModule} to a printed code to be straightforward.) So, $n \coloneq \lvert c\sref{instances\_init} \rvert = \lvert c\sref{instances} \rvert$, and, $\forall k \in \{1, \cdots, n \}$, $c\sref{instances\_init}_k = c\sref{instances}_{k,1}$.

  According to the B~specification, the order of initialization has importance.

\item The \textsf{values} field contains the concrete constants valuations, in order.
  
  \begin{adjustbox}{center}
    \(
    c\sref{values} = \left(\tau_\text{val}(i\sref{Values}_1, e), \cdots, \tau_\text{val}(i\sref{Values}_{n_v}, e)\right)
    \)
  \end{adjustbox}
  
\item The converted initialisation contains the translation of the \texttt{INITIALISATION}.
  
  \begin{adjustbox}{center}
    \(
    c\sref{initialisations} = \tau_\text{inst}(\{\}, i\sref{Initialisation}, e)
    \)
  \end{adjustbox}
\item Each operation in the implementation is translated by exactly one operation in the converted object, and each operation in the converted object can be associated with an unique operation in the implementation:
  \begin{enumerate}
  \item   \(\tau'_\text{op} \colon \left\{
        \begin{array}{ccl}
          \rus{i\sref{Operations}} & \longrightarrow & \rus{c\sref{functions}} \\
          o & \longmapsto & \tau_\text{op}(o, e)
        \end{array}
      \right. \text{(mind the codomain), and:}\)
  \item $\tau'_\text{op}$ is bijective.
  \end{enumerate}
\end{enumerate}


\subsection{From a converted shape to Rust code}

After the conversion to a converted shape ($c \in \mathcal{S}_\text{converted}$), {\br} "prints" $c$, {\ie} the Rust code, to a given file. Mathematically, it can be seen in this document as another conversion from $c$ to a printed code $p \in \mathcal{S}_\text{Rust}$. Note that some details (added newlines, for example) are not worth specifying.


\subsubsection{Definitions}

The conversion from $c$ to $p$ is very straightforward ({\br} was designed in this purpose) and there's not much to say about it. So, we dare to satisfy ourselves of the mere declaration of $\phi_\text{function}$, $\phi_\text{inst}$, $\phi_\text{exp}$, and $\phi_\text{var}$, the functions which translate a function, an instruction, an expression and a variable declaration, respectively.

However, there are some nuances. Firstly, with $\phi'_\text{pred}$ function, restriction of the $\phi_\text{pred}$ function which prints a predicate to $\st{RustPredicateAggregate}$:

\begin{adjustbox}{center}
\(
  \phi'_\text{pred} \colon \left\{
    \begin{array}{ccl}
      \st{RustPredicateAggregate} & \longrightarrow & \st{\_predicateaggregate} \\
      \Struct{
      \fot{predicates}{(p_1, \cdots, p_n)}, \\
      \fot{symbol}{o}
      } & \longmapsto & \left\{\begin{array}{l}
                        \text{if we define $\mu = \phi_\text{predicateaggregateop}(o)$, then:} \\
                        \OStruct{
                        \rtext{(}, \\
      \phi_\text{pred}(p_1), \\
      \left(
      \begin{array}{c}
        \OStruct{\rtext{) }, \mu, \rtext{ (}, \phi_\text{pred}(p_2)}, \\
        \cdots, \\
        \OStruct{\rtext{) }, \mu, \rtext{ (}, \phi_\text{pred}(p_n)}, \\
      \end{array}
      \right), \\
      \rtext{)}
      }
                        \end{array}\right.
      \end{array}
  \right.
  \)
\end{adjustbox}

With the following definition:
\[
  \phi_\text{predicateaggregateop} \colon \left\{
    \begin{array}{ccl}
      \st{comparisonSymbol} & \longrightarrow & \st{\_predicateaggregateop} \\
      \ulobj{And} & \longmapsto & \rtext{\&\&} \\
      \ulobj{Or} & \longmapsto & \rtext{||} \\
      \cdot & \longmapsto & \cdot \\
    \end{array}
  \right.
\]

Then, with the $\phi_\text{binexp}$ function which translates a binary expression:

\begin{adjustbox}{center}
  \(
  \phi_\text{binexp} \colon \left\{
    \begin{array}{ccl}
      \st{RustBinaryExpression} & \longrightarrow & \st{\_binaryexpression} \\
      
      \Struct{
      \fot{left\_expr}{e_1}, \\
      \imfdef{\ulobj{exponentiation},} \\
      \fot{right\_expr}{e_2}
      } & \longmapsto & \OStruct{
                        \rtext{(}, \\
      \phi_\text{exp}(e_1), \\
      \rtext{).pow((}, \\
      \phi_\text{exp}(e_2), \\
      \rtext{).try\_into().unwrap())} \\
      } \\

      \Struct{
      \fot{left\_expr}{e_1}, \\
      \imfdef{\ulobj{tabularPosition},} \\
      \fot{right\_expr}{e_2}
      } & \longmapsto & \OStruct{
      \phi_\text{exp}(e_1), \\
      \rtext{[(}, \\
      \phi_\text{exp}(e_2), \\
      \rtext{) as usize]} \\
      } \\

      \Struct{
      \fot{left\_expr}{e_1}, \\
      \fot{type}{t}, \\
      \fot{right\_expr}{e_2}
      } \text{ elsewise} & \longmapsto & \OStruct{
                                                       \rtext{(}, \\
      \phi_\text{exp}(e_1), \\
      \phi_\text{binexpop}(t), \\
      \phi_\text{exp}(e_2), \\
      \rtext{)}
      }      
    \end{array}
  \right.
  \)
\end{adjustbox}

With the following definition:
\[
  \phi_\text{binexpop} \colon \left\{
    \begin{array}{ccl}
      \st{binaryExpression} & \longrightarrow & \st{\_binaryexprop} \\
      \ulobj{addition} & \longmapsto & \rtext{) + (} \\
      \ulobj{substraction} & \longmapsto & \rtext{) - (} \\
      \ulobj{multiplication} & \longmapsto & \rtext{) * (} \\
      \ulobj{division} & \longmapsto & \rtext{) / (} \\
      \ulobj{modulo} & \longmapsto & \rtext{) \% (} \\
      \cdot & \longmapsto & \cdot \\
    \end{array}
  \right.
\]

Two remarks might worth the attention. Firstly, the binary expression are translated with parentheses everywhere, to prevent precedence problems; as drawback, the generated code might be unreadable (we might end up with lines such as \texttt{self.value = (self.value) + (1);}). Secondly, the exponentiation uses an awful \texttt{try\_into().unwrap()}. This is because the \texttt{pow} function require an unsigned integer as second argument, but the Rust compiler might interpret it as a signed integer, for instance in the expression \texttt{2.pow(self.value + 2)} if \texttt{value} is a \texttt{i32}. The \texttt{try\_into()} method parses the argument, for example from \texttt{i32} to \texttt{u32}; the \texttt{unwrap()} method helps to call a panic if the \texttt{try\_into} fails; but in our case, as the B~verification of our programs allows us to ensure that the second members are always unsigned integers, we can just parse it using \texttt{try\_into().unwrap()}. A similar problem happens with the \ulobj{tabularPosition} translation; the position of an array needs to have the \texttt{usize} type, so, it has to be parsed.


The $\phi_\text{functioncall}$ function which translates a function call; its inner workings is clear, except for the field \texttt{inits}; so, $\forall c \in \st{FunctionCall}$, if we define $n = \lvert c\sref{outputParameters} \rvert$,

\begin{adjustbox}{center}
\(
  \phi_\text{functioncall}(c)\sref{inits} = \left(
    \OStruct{
      \rtext{self.}, \\
      \phi_\text{exp}(c\sref{outputParameters}_1), \\
      \rtext{ = Default::default();\CR} \\
    }, \cdots, \OStruct{
      \rtext{self.}, \\
      \phi_\text{exp}(c\sref{outputParameters}_n), \\
      \rtext{ = Default::default();\CR} \\
    }
  \right)
  \)
\end{adjustbox}

A Rust function call has to be precedated by as many initializations as output parameters. This is because Rust refuses to call a function on uninitialized parameters.



Then, some remarks written using sentences:
\begin{itemize}
\item A \st{Declaration} is translated using the shape \texttt{let tmp1: i32;}, for example.
\item A \st{Block} is basically a new Rust context. It is translated by \texttt{\{...\}} (so, it just adds brackets). Remember that a local variables instruction in translated by a new block.
\item The output parameters are translated by mutable references (all functions are prototypes and will modify the mutable parameters instead of returning anything), and the input parameters are translated by immutable references. Rust is a language which doesn't like references, and, to put it in a nutshell, we cannot have two variables which are mutable references to the same place in memory, and we cannot have one if we have more than zero immutable reference to it. However, as mutable references are associated to new separate object created just before the call, and disapear afterwards, it is good to go.
\item Example of a \st{RustArray} translation: \texttt{[1, 2, 7, -2, 67 + 12]}. Example of a \st{tabular} translation: \texttt{[i32; 6]} for an array with six \texttt{i32} values.
\end{itemize}




\subsubsection{Properties verified by $c$ and $p$}

$c$ and $p$ verify the following properties:
\begin{enumerate}
\item The mods, uses, and name of the module is translated:

  \[
    \begin{array}{rl}
      p\sref{mods} &= \left( \OStruct{c\sref{mods}_1}, \cdots \right) \\
      p\sref{uses} &= \left( \OStruct{c\sref{uses}_1}, \cdots \right) \\
      p\sref{name}_1 = p\sref{name}_2 &= c\sref{name}
    \end{array}
  \]
\item The instances are also translated, with repetitions:

  \[
    p\sref{instances} = \left( \OStruct{c\sref{instances}_1, c\sref{instances}_2, c\sref{instances}_2}, \cdots \right)
  \]
\item Each variables declaration are translated into exactly one variable declaration, and conversely, each variable declaration in the Rust code can be associated with exactly one in the converted structure. Note that the order is not necessarily preserved.

  \begin{enumerate}
  \item   \(\phi'_\text{var} \colon \left\{
      \begin{array}{ccl}
        c\sref{variables} & \longrightarrow & \rus{p\sref{variables}} \\
        v & \longmapsto & \phi_\text{var}(v)
      \end{array}
    \right. \text{(mind the domain and codomain), and:}\)
  \item $\phi'_\text{var}$ is bijective.
  \end{enumerate}
\item Instances initialisations are also translated, with repetitions:

  \[
    p\sref{instances\_init} =
    \left( \OStruct{c\sref{instances\_init}_1, c\sref{instances\_init}_2}, \cdots \right)
  \]

\item Valuations are translated in order and the same way.
\item Initialisations instructions are translated in order. So, if $c\sref{initialisations} = (i_1, \cdots, i_{n_c})$ and $p\sref{initialisations} = (i'_1, \cdots, i'_{n_p})$,
  \begin{enumerate}
  \item $n_c = n_p$, and:
  \item $\forall k \in \left\{1, \cdots, n_c\right\}, i'_k = \phi_\text{inst}(i_k)$.
  \end{enumerate}
  
\item Each function in the converted structure matches with exactly one function in the Rust code, and conversely. Note that the order is not necessarily preserved.
  \begin{enumerate}
  \item   \(\phi'_\text{function} \colon \left\{
      \begin{array}{ccl}
        \rus{c\sref{functions}} & \longrightarrow & \rus{p\sref{functions}} \\
        f & \longmapsto & \phi_\text{function}(f)
      \end{array}
    \right. \text{(mind the domain and codomain), and:}\)
  \item $\phi'_\text{function}$ is bijective.
  \end{enumerate}
\end{enumerate}



\subsection{An example}

The following example of B~code is taken:

% \comp{
\begin{minipage}{0.6\textwidth}
\begin{verbatim}
MACHINE
    counter
VARIABLES
    value, overflow
INVARIANT
    value: INT & overflow: BOOL &
    0 <= value & value <= MAXINT &
    ((overflow = TRUE) => (value = MAXINT))
INITIALISATION
    value := 0 || overflow := FALSE
OPERATIONS
    zero =
    BEGIN
        value := 0 || overflow := FALSE
    END;
    inc =
    PRE
        value <= MAXINT
    THEN
        IF value < MAXINT THEN
            value := value + 1
        ELSE
            overflow := TRUE
        END
    END
END
\end{verbatim}
\end{minipage}
\hspace{0.7cm}
\begin{minipage}{0.6\textwidth}
\begin{verbatim}
IMPLEMENTATION
    counter_i
REFINES
    counter
SEES b2rust_types
CONCRETE_VARIABLES
    value, overflow
INVARIANT
    value: rust_i32 &
    overflow: rust_bool
INITIALISATION
    value := 0;
    overflow := FALSE
OPERATIONS
    zero =
    BEGIN
        value := 0;
        overflow := FALSE
    END;
    inc =
    BEGIN
        IF value < 2147483647 THEN
            value := value + 1
        ELSE
            overflow := TRUE
        END
    END
END
\end{verbatim}
\end{minipage}

This code is shown for the understanding of the reader; we shall not manipulate it directly in the translation procedure described in the document. {\br} works only on BXML files, and mathematically, a BXML file is represented by an element of $\mathcal{S}_\text{BXML}$. We call $a$ the abstraction BXML structure and $i$ the implementation BXML structure.

So, admit that we have:
\[
  a = \OStruct{
    \fot{Abstraction}{\rtext{}}, \\
    \fot{Imports}{\varnothing}, \\
    \fot{Values}{()}, \\
    \fot{Concrete\_Constants}{()}, \\
    \fot{Concrete\_Variables}{()}, \\
    \fot{Properties}{}{\{\}}, \\
    \fot{Invariant}{}{\cdots}, \\
    \fot{Initialisation}{}{\cdots}, \\
    \fot{Operations}{}{\cdots}
  }
\]

\begin{adjustbox}{center}
\(
  i = \OStruct{
    \fot{Abstraction}{\rtext{counter}}, \\
    \fot{Imports}{\varnothing}, \\
    \fot{Values}{()}, \\
    \fot{Concrete\_Constants}{()}, \\
    \fot{Concrete\_Variables}{(\Struct{\rtext{value}}, \Struct{\rtext{overflow}})}, \\
    \fot{Properties}{\{\}}, \\
    \fot{Invariant}{
      \Struct{
        \fot{pred\_group}{\left(
            \begin{array}{c}
              \OStruct{\Struct{\rtext{value}}, \Struct{\rtext{rust\_i32}}, \rtext{:}}, \\
              \OStruct{\Struct{\rtext{overflow}}, \Struct{\rtext{rust\_bool}}, \rtext{:}} \\
            \end{array}
          \right)}, \\
        \fot{op}{\rtext{\&}}
      }
    }, \\
    \fot{Initialisation}{
      \Struct{
        \fot{Sub}{\left(
            \begin{array}{c}
              \OStruct{(\Struct{\rtext{value}}), (\Struct{0})}, \\
              \OStruct{(\Struct{\rtext{overflow}}), (\Struct{\bot})}, \\
            \end{array}
          \right)}, \\
        \fot{op}{\rtext{;}}
      }
    }, \\
    \fot{Operations}{\left(
        \begin{array}{c}
          \OStruct{
          (), \\
          (), \\
          % TOCORRECT
          \varnothing, \\
          \Struct{
          \fot{Sub}{
          \left(
          \begin{array}{c}
            \OStruct{(\Struct{\rtext{value}}), (\Struct{0})}, \\
            \OStruct{(\Struct{\rtext{overflow}}), (\Struct{\bot})}, \\
          \end{array}              
          \right)
          }, \\
          \fot{op}{\rtext{;}}
          }, \\
          \rtext{zero}
          }, \\
          \OStruct{
          (), \\
          (), \\
          % TOCORRECT
          \varnothing, \\
          \Struct{
          \fot{Sub}{
          \left(
          \begin{array}{c}
            \Struct{
            \fot{Condition}{
            \OStruct{\Struct{\rtext{value}}, \Struct{2147483647}, \rtext{<}}
            }, \\
            \fot{Then}{
            \OStruct{(\Struct{\rtext{value}}), (\OStruct{\Struct{\rtext{value}}, \Struct{1}, \rtext{+}})}
            }, \\
            \fot{Else}{
            \OStruct{(\Struct{\rtext{overflow}}), (\Struct{\top})}
            }, \\
            \fot{elseif}{\rtext{no}}
            }
          \end{array}              
          \right)
          }, \\
          \fot{op}{\rtext{;}}
          }, \\
          \rtext{inc}
          }
        \end{array}
      \right)
    }
  }
  \)
  \end{adjustbox}

{\br} works on these elements we represent as $i$ and $a$ and converts them into an element we represent as $c \in \mathcal{S}_\text{converted}$. How does it look like? To know it, let us go over the different properties as given in section~\ref{conversion}:

\begin{enumerate}
\item \label{exMods} There’s no imports in this example. So, $c\sref{mods} = \varnothing$.
\item \label{exUses} For the same reasons, $c\sref{uses} = \varnothing$.
\item \label{exName} As $i\sref{Abstraction} = \rtext{counter}$, $c\sref{name} = \rtext{counter}$. This one is easy.
\item \label{exInstances} For the same reasons, $c\sref{imports} = \varnothing$.
\item The property becomes :

  \[
    \forall v \in \{\OStruct{\rtext{value}}, \OStruct{\rtext{overflow}}\}, \left(v\sref{value}, \tau_T\left( T_{v, i}(v) \right)\right) \in c\sref{variables}
  \].

  $T_{v, i}(\OStruct{\rtext{value}})$ is $\rtext{rust\_i32}$. This is because, as $i\sref{Invariant}\sref{pred\_group} \notin \st{Exp\_Comparison}$ (it is a \st{Nary\_Pred}), $e_c \in i\sref{Invariant}\sref{pred\_group}$. Only one invariant matches the properties \textsc{iii} to \textsc{vi}: $(\OStruct{\rtext{value}}, \OStruct{\rtext{rust\_i32}}, \rtext{:})$.

  For the same reasons, $T_{v, i}(\OStruct{\rtext{overflow}})$ is $\rtext{rust\_bool}$.

  If we apply the $\tau_T$ type-conversion function, we get that

  \[
    \{(\rtext{value}, \ulobj{i32\_t}), (\rtext{overflow}, \ulobj{bool\_t})\} \subset c\sref{variables}.
    \]
\item We could follow the same rule, but as there's no concrete constant defined, it is useless. We only get that $\{\} \subset c\sref{variables}$, which is not very useful.
\item This property ensures that
  \[c\sref{variables} = \{(\rtext{value}, \ulobj{i32\_t}), (\rtext{overflow}, \ulobj{bool\_t})\}.\]
  Let $(l, t) \in c\sref{variables}$. The property ensures that $l$ is defined somewhere as a concrete variable or concrete constant in $a$ or $i$, so:
  \begin{enumerate}
  \item Either $l = \rtext{value}$. Then, $\exists v \in \st{Id}, v\sref{value} = \rtext{value}$ and in this case $(v, t) = (\OStruct{\rtext{value}}, T_{v, i}(\OStruct{\rtext{value}})) = (\rtext{value}, \ulobj{i32\_t})$.
  \item Or, $l = \rtext{overflow}$. Then, for the same reasons, we get that $(v, t) = (\rtext{overflow}, \ulobj{bool\_t})$.
  \end{enumerate}
\item \label{exInstancesInit} There’s no imports in this example. So, $c\sref{instances\_init} = \varnothing$.
\item There is nothing is $i\sref{Values}$, so, the equation becomes:
  \begin{align*}
    c\sref{initialisations} &= \tau_\text{inst}((), i\sref{Initialisation}, \{\}) \\
                            &= \tau_\text{narysub}\left((), i\sref{Initialisation}, \{\}\right) \\
                            &= \tau_\text{inst}\left(\tau_\text{inst}((), i\sref{Initialisation}\sref{Sub}_1, \{\}), i\sref{Initialisation}\sref{Sub}_2, \{\}\right) \\
                            &= \tau_\text{inst}\left(\tau_\text{inst}\left((), \OStruct{
                              (\Struct{\rtext{value}}), \\
    (\Struct{0})
    },
    \{\}\right), \OStruct{
    (\Struct{\rtext{overflow}}), \\
    (\Struct{\bot})
    },
    \{\}\right) \\
                            &= \left(
                              \Struct{
                              \fot{variable}{\tau_\text{exp}(\rtext{value}, \{\})} \\
    \fot{expression}{\tau_\text{exp}(0, \{\})} \\
    },
    \Struct{
    \fot{variable}{\tau_\text{exp}(\rtext{overflow}, \{\})} \\
    \fot{expression}{\tau_\text{exp}(\bot, \{\})} \\
    } \right)
  \end{align*}
  etc.
\item It tells us exactly the contents of $c\sref{functions}$. We need to follow the translation functions.
  % Should be updated...
\end{enumerate}

Now we know exactly how does $c$ look like:

\begin{adjustbox}{center}
  \(
  c = \Struct{
    \fot{mods}{\varnothing}, \\
    \fot{uses}{\varnothing}, \\
    \fot{name}{\rtext{counter}}, \\
    \fot{instances}{\varnothing}, \\
    \fot{variables}{\{(\rtext{value}, \ulobj{i32\_t}), (\rtext{overflow}, \ulobj{bool\_t})\}}, \\
    \fot{instances\_init}{\varnothing}, \\
    \fot{initialisations}{\left(
        \begin{array}{c}
          \Struct{
          \fot{variable}{\rtext{value}}, \\
          \fot{expression}{\Struct{0}}
          }, \\
          \Struct{
          \fot{variable}{\rtext{overflow}}, \\
          \fot{expression}{\Struct{\bot}}
          }
        \end{array}
      \right)}, \\
    \fot{functions}{\left(
        \begin{array}{c}
          \Struct{
          \fot{name}{\rtext{zero}}, \\
          \fot{inputParameters}{\{\}}, \\
          \fot{outputParameters}{\{\}}, \\
          \fot{instructions}{\left(
          \begin{array}{c}
            \Struct{
            \fot{variable}{\rtext{value}}, \\
            \fot{expression}{\Struct{0}}
            }, \\
            \Struct{
            \fot{variable}{\rtext{overflow}}, \\
            \fot{expression}{\Struct{\bot}}
            }
          \end{array}
          \right)}
          }, \\
          \Struct{
          \fot{name}{\rtext{inc}}, \\
          \fot{inputParameters}{\{\}}, \\
          \fot{outputParameters}{\{\}}, \\
          \fot{instructions}{\left(
          \begin{array}{c}
            \Struct{
            \fot{predicate}{\Struct{
            \fot{left\_expr}{\Struct{\rtext{value}}}, \\
            \fot{symbol}{\ulobj{LessThan}}, \\
            \fot{right\_expr}{\Struct{2147483647}}
            }}, \\
            \fot{then\_instr}{\left(
            \begin{array}{c}
              \Struct{
              \fot{variable}{\rtext{value}}, \\
              \fot{expression}{
              \Struct{
              \fot{left\_expr}{\Struct{\rtext{value}}}, \\
              \fot{type}{\Struct{\ulobj{addition}}}, \\
              \fot{right\_expr}{\Struct{1}}
              }
              }
              }
            \end{array}
            \right)}, \\
            \fot{else\_instr}{\left(
            \Struct{
            \fot{variable}{\rtext{overflow}}, \\
            \fot{expression}{\Struct{\top}}
            }
            \right)}
            }
          \end{array}
          \right)}
          }
        \end{array}
      \right)}
  }
  \)
\end{adjustbox}


% \]
    %       \right)}
    %       }, \\



{\br} then prints the converted object. In this document, it is represented as a translation to a $p \in \mathcal{S}_\text{Rust}$ element. Its translation is straightforward and we have:

\[
  p = \OStruct{
    \rtext{\#[derive(Default)]\CR} \\
    \rtext{pub struct }, \rtext{counter}, \rtext{ \{\CR}, \\
    \rtext{// Instances of imported modules.\CR}, \\
    \rtext{// Concrete variables \& constants.\CR}, \\
    \left(
      \begin{array}{c}
        \OStruct{\rtext{r\#}, \rtext{value}, \rtext{: }, \rtext{i32}, \rtext{,\CR}}, \\
        \OStruct{\rtext{r\#}, \rtext{overflow}, \rtext{: }, \rtext{bool}, \rtext{,\CR}}
      \end{array}
    \right), \\
    \rtext{\}\CR} \\
    \rtext{\CR} \\
    \rtext{impl }, \rtext{counter}, \rtext{ \{ \CR} \\
    \rtext{pub fn initialisation(\&mut self) \{\CR}, \\
    \rtext{// Instances of imported modules initialization.\CR}, \\
    \rtext{\CR// `INITIALISATION` clause.\CR}, \\
    \left(
      \begin{array}{c}
        \OStruct{\Struct{\rtext{r\#}, \rtext{value}}, \rtext{ = }, \Struct{\rtext{0}}, \rtext{;\CR}}, \\
        \OStruct{\Struct{\rtext{r\#}, \rtext{overflow}}, \rtext{ = }, \Struct{\rtext{\rtext{false}}}, \rtext{;\CR}}
      \end{array}
    \right), \\
    \rtext{\}\CR}, \\
    \left(
      \begin{array}{c}
        \OStruct{
        \rtext{{\CR}} \\
        \rtext{pub fn }, \rtext{zero}, \rtext{(\&mut self) \{\CR}, \\
        \left(
        \begin{array}{c}
          \OStruct{
          \Struct{\rtext{r\#}, \rtext{value}}, \rtext{=}, \Struct{0}, \rtext{;\CR}
          }, \\
          \OStruct{
          \Struct{\rtext{r\#}, \rtext{overflow}}, \rtext{=}, \Struct{\rtext{false}}, \rtext{;\CR}
          }, \\
        \end{array}
        \right), \\
        \rtext{\}\CR}
        }, \\
        \OStruct{
        \rtext{{\CR}} \\
        \rtext{pub fn }, \rtext{inc}, \rtext{(\&mut self) \{\CR}, \\
        \left(
        \begin{array}{c}
          \OStruct{
          \rtext{if }, \\
          \OStruct{\rtext{self.}, \rtext{r\#}, \rtext{value}, \rtext{ < }, \rtext{2147483647}}, \\
          \rtext{ \{\CR}, \\
          \left(
          \OStruct{
          \rtext{r\#}, \Struct{\rtext{value}}, \rtext{ = }, \OStruct{\rtext{r\#}, \Struct{\rtext{value}}, \rtext{+}, \Struct{\rtext{1}}}, \rtext{;\CR}}
          \right), \\
          \rtext{\} else \{}, \\
          \left(
          \OStruct{\Struct{\rtext{r\#}, \rtext{overflow}}, \rtext{ = }, \Struct{\rtext{true}}, \rtext{;\CR}}
          \right), \\
          \rtext{\}\CR}
          }
        \end{array}
        \right), \\
        \rtext{\}\CR}
        }
      \end{array}
    \right), \\
    \rtext{\}\CR}
  }
\]

The output of {\br} will be the following:

\begin{verbatim}
#[derive(Default)]
pub struct counter {
// Concrete variables & constants.
r#overflow: bool,
r#value: i32,
}

impl counter {
pub fn initialisation(&mut self) {
// `INITIALISATION` clause.
self.r#value = 0;
self.r#overflow = false;
}

pub fn zero(&mut self) {
self.r#value = 0;
self.r#overflow = false;
}

pub fn inc(&mut self) {
if self.r#value < 2147483647 {
self.r#value = (self.r#value) + (1);
} else {
self.r#overflow = true;
}
}
}
\end{verbatim}

The output can then be formatted using another program, for example \texttt{rustfmt}. There are some differences with the expecting behavior, concerning the newlines and comments. For a sake of simplicity, they have not been correctly specified.


\section{Inner workings of {\br}}
\label{SectionInnerWorkings}

Although a B0~program is quite algorithmic and one can think its translation might be straightforward, the inner workings of {\br} can be interesting, for instance for the implementation of another converter, or, of course, for maintenance purposes.

{\br} is programmed with the following technologies, by decreasing order of importance:
\begin{itemize}
\item C++, for all the code concerning the execution of {\br}, the parsing of the BXML, its conversion, and the printing of the Rust code.
\item Bash, for all the tests scripts.
\item CMake, for the compilation.
\item Rust and XML, for the test reference files.
\end{itemize}


\subsection{The testing}

All the files related to the testing can be found in the \texttt{tests} directory. If you want to test {\br}, the section~\ref{testing} should be the one you are looking for. Here, we will only explain its technical aspects.

Each category of test uses a script, \texttt{test.sh}, you can find in its dedicated directory; however, this script is not invoked manually; CMake, invoked when testing with the \texttt{ctest .} command, reads a \texttt{tests\_file.cmake} which contains the commands compelling it to run the scripts with correct parameters; however, the lines in this file are generated automatically so that a tester is not compelled to add a line manually. It is the purpose of the script \texttt{gen\_tests.sh}, automatically called by the \texttt{cmake .} command, which goes over each category of test to find all its tests.


\subsection{The compilation}

There is not much to say; CMake uses the \texttt{CMakeLists.txt} instruction file which, in particular, orders CMake to run the \texttt{gen\_tests.sh} script each time a user executes \texttt{cmake .} and to tell it what to test when running \texttt{ctest .}; at the beginning of the file, it has options which concern the compilation and can be changed.


% Merged into a dedicated section
% \subsection{The conversion}

% \subsubsection{Global structure}
% \noindent
% \begin{figure}
%   \centering
%   \begin{adjustbox}{center}
%     \begin{tikzpicture}
%       \node [draw, text width=2.2cm] (input) at (0, 2) {
%         \centering{Input} \\
%         \texttt{\footnotesize input.\{cpp, h\}}
%       };
%       \node [draw, very thick, rounded corners, text width=2.5cm] (b2rust) at (0, 0) {
%         \centering{b2rust} \\
%         \texttt{\footnotesize b2rust.\{cpp, h\}}
%       };
%       \node [draw, rounded corners, text width=3.3cm] (parser) at (-4, 0) {
%         \centering{Parser} \\
%         \texttt{\footnotesize parser/parser.\{cpp, h\}}
%       };
%       \node [draw, rounded corners, text width=1.7cm] (converter) at (-1, -1.5) {
%         \centering{Converter} \\
%       };
%       \node [draw, text width=1.5cm] (printer) at (6, 0) {
%         \centering{Printer} \\
%         \texttt{\footnotesize printer/*}
%       };
%       \node[draw, text width=5cm] (machine) at (-4, -3) {
%         \centering{Machine} \\
%         \texttt{\footnotesize parser/machine.\{cpp, h\} \\
%           parser/operation.\{cpp, h\} \\
%           parser/concrete\_constant.\{cpp, h\}
%         }
%       };
%       \node[draw, text width=3.5cm] (checker) at (-4, -5) {
%         \centering{Checker} \\
%         \texttt{\footnotesize parser/checker.\{cpp, h\}
%         }
%       };
%       \node[draw, text width=4cm] (tinyxml2ext) at (1, -5) {
%         \centering{TinyXML2Ext} \\
%         \texttt{\footnotesize parser/tinyxml2ext.\{cpp, h\}}
%       };
%       \node[draw, inner sep=0.2cm] (tinyxml2) at (1, -3.7) {TinyXML2};
%       \node[draw, text width=4.5cm] (module) at (6, -3) {
%         \centering{Module} \\
%         \texttt{\footnotesize converter/module.\{cpp, h\} \\
%           converter/function.\{cpp, h\} \\
%           converter/expression.\{cpp, h\} \\
%           converter/constant.\{cpp, h\} \\
%         }
%       };
%       \node[draw, text width=4.5cm] (cprinter) at (3, -1.2) {
%         \centering{Components printers} \\
%         \texttt{\footnotesize printer/component\_printers.cpp \\
%         }
%       };

%       \draw[->] (b2rust) -- (input);
%       \draw[->] (b2rust) -- (parser);
%       \draw[->] (b2rust) -- (converter);
%       \draw[->] (b2rust) -- (printer);
%       \draw[->] (parser) -- (input);
%       \draw[->] (parser) -- (machine);
%       \draw[->] (printer) -- (input);
%       \draw[->] (converter) -- (machine);
%       \draw[->] (converter) -- (module);
%       \draw[->] (printer) -- (module);
%       \draw[->] (module) -- (machine);
%       \draw[dashed, ->] (machine) -- (tinyxml2);
%       \draw[->] (machine) -- (checker);
%       \draw[->] (machine) -- (tinyxml2ext);
%       \draw[dashed, ->] (tinyxml2ext) -- (tinyxml2);
%       \draw[->] (printer) -- (cprinter);
%       \draw[<->] (cprinter) -- (module);
%     \end{tikzpicture}
%   \end{adjustbox}
%   \caption{\label{mechanism}The inner workings of {\br}. Each node represents a "component", conceptually speaking, which can consist of none or several files (whose name, if applicable, are always written). $A \longrightarrow B$ means the $A$ component uses the $B$ component (it depends on it). A dashed line means the same, except $B$ is an external component. Some component are entirely represented by a class with the same name; they are boxed with sharp edges. Please note that the following files are not represented on this diagram, because they can be used by any file: the \texttt{debug.cpp} file which overloads the \texttt{<<} operator; the \texttt{error\_codes.h} which defines the error enum.}
% \end{figure}
% {\br} consists of a main source file, \texttt{b2rust.cpp}, which:

% \begin{itemize}
% \item Creates an \texttt{Input} object from the command lines arguments. This is done because:
%   \begin{enumerate}
%   \item When a command line argument is needed, it shouldn't be the role of every function to parse the \texttt{argv} argument. Instead, it is better to just query an attribute of an "Input" object;
%   \item Not all functions should be able to access the command line arguments;
%   \item The despicable \texttt{const char*} arguments have to be converted into nice \texttt{string} elements (maybe see \hyperref[SectionCoding]{the development conventions section}).
%   \end{enumerate}
% \item Creates a \texttt{Printer} object. This object contains a function to print a converted program (\texttt{PrintIt}). It is constructed using the input object and has the output file name as private attribute to prevent the code printing from any other component. Also, some important tasks like closing buffer can be done in its destructor.
% \item Calls three components and, maybe, pass the return of the latter as an argument of the next. These components entirely make up {\br} and each has a specific goal:
%   \begin{enumerate}
%   \item The \textit{parser}, which takes the path of a BXML file as entry and uses an external library, \texttt{tinyxml2}, to read all relevant information in the file; it parses them into a C++ object, whose class is \texttt{machine}. If {\br} needs an information from the XML file, it has to be in the object; the parsing of the BXML file has to be done through the parser. It also checks if {\br} can translate the program, so, if something bad is found, or of the \texttt{--check-only} option is specified, it stops there.
%   \item The \textit{converter}, which takes the machine object as entry, and works on it to convert it into an C++ object of the \texttt{module} class. The module object needs to be, architecturally, fairly close to a Rust source code, letting to the third component only the difficulty to print the code from C++ objects. The attributes of the module object and the one of its recursive subobjects have to be entirely figured out by {\br}, {\ie} using C++ basic types and not always strings.
%   \item The \textit{printer}, which takes the module object as entry and prints the associated Rust code. It shouldn't be more difficult than recursively going over all its attributes and subobjects, however, it is the component which deals with all the Rust syntax.
%   \end{enumerate}
% \end{itemize}

% The figure~\ref{mechanism} can help with the understanding of the operating mechanism of {\br}.


% TODO: rewrite this.
% \subsection{The classes}

% The usage of classes can be quite useful in C++. One if its main practical usage which was used in the development of {\br} is the usage of \texttt{const} and \texttt{private} attributes (see section~\ref{SectionCodingConstPrivate}). It allows the components described in the figure~\ref{mechanism} to be "correctly separated", which means that a component cannot use something it shouldn't.

% For example, the \texttt{Machine} object, which is a fairly big and important object in our project, is given as argument to the converter, but, as it is not its role to modify the object, every attribute of the \texttt{Machine} object is declared as \texttt{const}. It raises some difficulties; for example, the constructor of the \texttt{Machine} object, which contains all the important code, has to use an initializer list which \textit{can} compels us to use temporary attribute or dedicated functions, declared as private.

% However, the code might be better written. For example, most classes have a \texttt{PrintMe} function which is used in the printing. However, no solution was found to prevent its use to components other than the printer. Hopefully, the \texttt{PrintMe}s return \texttt{string} types so the components other than the printer cannot output code (because they don’t have access to the \texttt{Printer} class). Also, it might be useful to compel the \texttt{PrintMe} function definition for some classes, maybe using a pure virtual parent class.



\subsection{Debugging}

The important classes overload the C++ \texttt{<<} operator to help a developer to debug {\br}. It allows the developer just to write \texttt{std::cout << object} to print most useful objects.


% NO
% \section{Clause translation}

% \subsection{The OPERATIONS clause}

% To translate the operations, we go over each operation and create an operation of the same name in the machine object. Currently, it is quite easy. In Rust, a "skip" function named \texttt{hello} is written:

% \begin{verbatim}
% fn hello() {
% }
% \end{verbatim}


% \subsection{The CONCRETE\_CONSTANTS clause}

% It is not very complicated because the constants have to be defined just once and their value are never changed again. We go over each concrete constant, get its name, and create a field in the machine object which contains its unchanged name. Yet, we need to get its type and valuation. Therefore, we need to search in the VALUES clause for an element with the name \texttt{Valuation} whose "ident" attribute is its name (figure~\ref{constant}).
% \begin{figure}
%   \centering
% \begin{verbatim}
% <Machine ...>
%   <Values>
%     <Valuation ident='test' typref='1'>
%       <Integer_Literal value='7' typref='1'/>
%     </Valuation>
%     ...
%   </Values>
%   <Concrete_Constants>
%     <Id value='test' typref='0'/>
%     ...
%   </Concrete_Constants>
%   ...
% </Machine>
% \end{verbatim}
%   \caption{\label{constant}The valuation and the type of the concrete constant \texttt{test} defined in the \texttt{Concrete\_Constants} element can be found in a \texttt{Valuation} element whose \texttt{ident} attribute is also \texttt{test}; it has an element whose name (\texttt{Integer\_Literal}) and \texttt{value} attribute state it is an integer whose value is $7$. Note that the \texttt{typref} attribute is quite useless for now as its purpose is to be used if there is no \texttt{Valuation} element matching the constant, which shouldn't be the case if the program has been proven by {\ab}.}
% \end{figure}
% The element contains the information of the type and the valuation.

% Basically, the machine object contains a field for the concrete constants whose name is \texttt{constants}. It is a vector of objects of type \texttt{Constant} which is itself a class which has:
% % TODO: prevent a new page (and possibly a figure insertion) here.
% \begin{itemize}
% \item A name;
% \item An expression object.
% \end{itemize}

% The \texttt{Expression} class is a \textit{pure virtual class} which compels the expression's class to be a subclass of it; it is how an expression can be simultaneously an object of the class \texttt{Int}, \texttt{Bool}, or something else.

% The constant can then be printed by the printer. For example, if we follow the example of the figure~\ref{constant}, the following line should be in the generated Rust program:
% \begin{verbatim}
% let const test: i32 = -7;
% \end{verbatim}
% Please note that for now, the B \texttt{Integer\_Literal} is translated as a signed integer coded on 32~bits (\texttt{i32} in Rust). It is expected that {\br} could read user translation preferences so that an \texttt{Integer\_Literal} could be translated as something else.


% \subsection{The VALUES clause}

% The VALUES clause is not directly parsed or translated; its elements are only read if needed when translating other clauses such as CONCRETE\_CONSTANTS.


\section{Development conventions}
\label{SectionCoding}

\subsection{In the conversion code}

\subsubsection{\texttt{const} and \texttt{private} whenever possible}
\label{SectionCodingConstPrivate}

Please use \texttt{const} whenever possible, even it this means writing things such as \texttt{const char* const* const} and writing public accessors. Its usage just needs to:
\begin{itemize}
\item Be able to compile (fortunately),
\item Be useful, {\ie} mean anything (no \texttt{new const Object}, for example).
\end{itemize}

It shall help having a bug-free code. However, this convention is not currently is use everywhere, because it is time-consuming.


\subsubsection{\texttt{std::string}}

If you contribute to the development of {\br}, please use \texttt{std::string} objects instead of \texttt{const char*} or \texttt{char*} ones. \texttt{tinyxml2} functions use \texttt{const char*} values as argument, so it is the purpose of the \texttt{tinyxml2ext} component to parse the arguments; but except for the \texttt{main} and \texttt{tinyxml2ext} components, the use of \texttt{std::string} shall be preferred.

If an use of \texttt{char*} is absolutely mandatory ({\eg} because you need to use an external library), use the comment "This one is fine." on the same line as the \texttt{char} usage.  This will allow us to check the absence of \texttt{char*}s in the whole code using a command line \texttt{grep -rn "char\textbackslash*"}, for example.


% \subsection{In the documentation}

\subsubsection{Various good C++ practices}

Respect recommended C++ practices, {\eg} never use \texttt{using namespace std} and never use \texttt{using namespace} in header files.


\subsection{In the Git repository}

Please only push code which compiles, and, if possible, whose documentation is up-to-date.


\section{Appendix}

\subsection{Error codes of {\br}}
\label{errors}

% TODO: prettier tabular plz :)
\begin{adjustbox}{center}
  \begin{tabular}{r c p{\textwidth}}
    \texttt{OK} & 0 & The program behaved as expected. This does not mean no error occurred, but if an error occurred, it did not concern the conversion (\ie the conversion would have been the same even without this error and is likely correct). \\
    \texttt{ERR\_SYNTAX} & 1 & The call syntax of the program was not respected. \\
    \texttt{ERR\_OUTPUT\_FILE} & 2 & The output file could not be created, or could not be opened with the write permission. \\
    \texttt{ERR\_OUTPUT\_STREAM} & 3 & Could not write to output stream. R/W or logical error on I/O operation. \\
    \texttt{ERR\_BXML\_LOADING} & 10 & The BXML file could not be loaded. \\
    \texttt{ERR\_BXML\_CHECKING} & 20 & An error occurred during the BXML checking. There’s at least one error. Either the file is not BXML compliant, or an element cannot be converted yet. \\
    \texttt{ERR\_BXML\_LACK} & 21 & An error occurred during the conversion. The file is BXML compliant and all its elements can be converted, but an element is lacking to allow the conversion. Do your files represent a verified B~program? If yes, it is a b2rust error.
  \end{tabular}
\end{adjustbox}


\subsection{{\br} relevant Rust types}
\label{appendixTypes}

\begin{adjustbox}{center}
  \begin{tabular}{c c p{\textwidth}}
    Type name & Description \\
    \texttt{i32} & A signed integer coded on 32~bits. \\
    \texttt{i16} & A signed integer coded on 16~bits. \\
    \texttt{i8} & A signed integer coded on 8~bits. \\
    \texttt{bool} & A boolean. \\
  \end{tabular}
\end{adjustbox}


\subsection{Assumed BXML specification errors}
\label{bxmlimprecisions}

The BXML~1.0 specification contains imprecisions which are obvious enough we suppose they will be corrected. The next assumptions might be made during the specification of {\br}:

\begin{enumerate}
\item Inside the \texttt{Operation\_Call} element, inside the \texttt{Output\_Parameters} element: a sequence of \texttt{Exp} is specified; we suppose it is a sequence of \texttt{Id}.
\end{enumerate}


\begin{center}
  \textsc{End of document.}
\end{center}


\end{document}